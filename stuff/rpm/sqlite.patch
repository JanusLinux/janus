From 07129b641b733ab30995c93e2b08d0673b9d218c Mon Sep 17 00:00:00 2001
From: Panu Matilainen <pmatilai@redhat.com>
Date: Tue, 24 Sep 2019 11:24:06 +0300
Subject: [PATCH] Add an experimental sqlite based rpmdb backend

All normal functionality is expected to work. Automatic generation
of missing index tables is missing, but that's not relevant at this time.
Going forward, we'll also want some sort of compatibility tracking
for the sql schema.

The database scheme basically just mirrors what BDB does, using strings
for strings and blobs for everything else due to the way integers are
handled in the sqlite C API, for now at least. Some amount of schema
changes are to be expected before this is considered final.

Performance is similar or better with BDB in the current unsafe CDB
model, but sqlite uses proper database transactions so this is expected
to be an order of magnitude more robust.

Many things are stupid and/or kind of backwards here due to the internal
API, which I've avoided changing in order to keep it backportable for the
time being. https://github.com/rpm-software-management/rpm/pull/836 is
needed but otherwise this should drop quite trivially into 4.14.x too.
However as we're planning for a longer term future here, it would be dumb
to limit ourselves by what's possible with an internal BDB-oriented API,
so I've fairly major changes planned in that direction.
---
 configure.ac         |  23 ++
 lib/Makefile.am      |   6 +
 lib/backend/dbi.c    |  14 +
 lib/backend/dbi.h    |   5 +
 lib/backend/sqlite.c | 604 +++++++++++++++++++++++++++++++++++++++++++
 macros.in            |   1 +
 6 files changed, 653 insertions(+)
 create mode 100644 lib/backend/sqlite.c

diff --git a/configure.ac b/configure.ac
index 43bbcb3ce..6fb8d98fa 100644
--- a/configure.ac
+++ b/configure.ac
@@ -611,6 +611,29 @@ if test "x$have_lmdb" = "xyes"; then
 fi
 AM_CONDITIONAL([LMDB], [test "x$have_lmdb" = "xyes"])
 
+# Check for SQLITE support
+AC_ARG_ENABLE([sqlite],
+              [AS_HELP_STRING([--enable-sqlite=@<:@yes/no/auto@:>@)],
+                              [build with sqlite rpm database format support (default=auto)])],
+              [enable_sqlite="$enableval"],
+              [enable_sqlite=auto])
+
+AS_IF([test "x$enable_sqlite" != "xno"], [
+  PKG_CHECK_MODULES([SQLITE], [sqlite3], [have_sqlite=yes], [have_sqlite=no])
+  AS_IF([test "$enable_sqlite" = "yes"], [
+    if test "$have_sqlite" = "no"; then
+      AC_MSG_ERROR([--enable-sqlite specified, but not available])
+    fi
+  ])
+])
+
+if test "x$have_sqlite" = "xyes"; then
+  AC_DEFINE([WITH_SQLITE], [1], [Define if SQLITE is available])
+  SQLITE_REQUIRES=sqlite
+  AC_SUBST(SQLITE_REQUIRES)
+fi
+AM_CONDITIONAL([SQLITE], [test "x$have_sqlite" = "xyes"])
+
 AM_GNU_GETTEXT_VERSION([0.16.1])
 AM_GNU_GETTEXT([external])
 AM_ICONV
diff --git a/lib/Makefile.am b/lib/Makefile.am
index 81f4eba61..d59eb22e8 100644
--- a/lib/Makefile.am
+++ b/lib/Makefile.am
@@ -86,6 +86,12 @@ librpm_la_SOURCES += \
 	backend/lmdb.c
 endif
 
+if SQLITE
+AM_CPPFLAGS += $(SQLITE_CFLAGS)
+librpm_la_LIBADD += $(SQLITE_LIBS)
+librpm_la_SOURCES += backend/sqlite.c
+endif
+
 tagtbl.C: Makefile.am $(srcdir)/rpmtag.h gentagtbl.sh
 	@AWK=${AWK} ${SHELL} $(srcdir)/gentagtbl.sh \
 		    	     $(srcdir)/rpmtag.h > $@.new && \
diff --git a/lib/backend/dbi.c b/lib/backend/dbi.c
index f391d774d..49a108f63 100644
--- a/lib/backend/dbi.c
+++ b/lib/backend/dbi.c
@@ -39,6 +39,11 @@ dbDetectBackend(rpmdb rdb)
     char *db_backend = rpmExpand("%{?_db_backend}", NULL);
     char *path = NULL;
 
+#if defined(WITH_SQLITE)
+    if (!strcmp(db_backend, "sqlite")) {
+	rdb->db_ops = &sqlite_dbops;
+    } else
+#endif
 #if defined(WITH_LMDB)
     if (!strcmp(db_backend, "lmdb")) {
 	rdb->db_ops = &lmdb_dbops;
@@ -59,6 +64,15 @@ dbDetectBackend(rpmdb rdb)
     }
 #endif
 
+#if defined(WITH_SQLITE)
+    path = rstrscat(NULL, dbhome, "/rpmdb.sqlite", NULL);
+    if (access(path, F_OK) == 0 && rdb->db_ops != &sqlite_dbops) {
+	rdb->db_ops = &sqlite_dbops;
+	rpmlog(RPMLOG_WARNING, _("Found sqlite rpmdb.sqlite database while attempting %s backend: using sqlite backend.\n"), db_backend);
+    }
+    free(path);
+#endif
+
 #if defined(WITH_LMDB)
     path = rstrscat(NULL, dbhome, "/data.mdb", NULL);
     if (access(path, F_OK) == 0 && rdb->db_ops != &lmdb_dbops) {
diff --git a/lib/backend/dbi.h b/lib/backend/dbi.h
index 83330494b..7d8e892e9 100644
--- a/lib/backend/dbi.h
+++ b/lib/backend/dbi.h
@@ -277,6 +277,11 @@ RPM_GNUC_INTERNAL
 extern struct rpmdbOps_s lmdb_dbops;
 #endif
 
+#if defined(WITH_SQLITE)
+RPM_GNUC_INTERNAL
+extern struct rpmdbOps_s sqlite_dbops;
+#endif
+
 RPM_GNUC_INTERNAL
 extern struct rpmdbOps_s dummydb_dbops;
 
diff --git a/lib/backend/sqlite.c b/lib/backend/sqlite.c
new file mode 100644
index 000000000..b51a2ce20
--- /dev/null
+++ b/lib/backend/sqlite.c
@@ -0,0 +1,604 @@
+#include "system.h"
+
+#include <sqlite3.h>
+
+#include <rpm/rpmlog.h>
+#include <rpm/rpmfileutil.h>
+#include "lib/rpmdb_internal.h"
+
+#include "debug.h"
+
+static const int sleep_ms = 50;
+
+struct dbiCursor_s {
+    sqlite3 *sdb;
+    sqlite3_stmt *stmt;
+    const char *fmt;
+    int flags;
+    rpmTagVal tag;
+    int ctype;
+
+    const void *key;
+    unsigned int keylen;
+};
+
+static rpmRC sqlite_pkgdbNew(dbiIndex dbi, dbiCursor dbc,  unsigned int *hdrNum);
+static int sqlexec(sqlite3 *sdb, const char *fmt, ...);
+
+static int dbiCursorResult(dbiCursor dbc)
+{
+    int rc = sqlite3_errcode(dbc->sdb);
+    int err = (rc != SQLITE_OK && rc != SQLITE_DONE);
+    if (err) {
+	rpmlog(RPMLOG_ERR, "%s: %d: %s\n", sqlite3_sql(dbc->stmt),
+		sqlite3_errcode(dbc->sdb), sqlite3_errmsg(dbc->sdb));
+    }
+    return err ? RPMRC_FAIL : RPMRC_OK;
+}
+
+static int dbiCursorReset(dbiCursor dbc)
+{
+    int rc = sqlite3_finalize(dbc->stmt);
+    dbc->stmt = NULL;
+    dbc->fmt = NULL;
+    return rc;
+}
+
+static int dbiCursorPrep(dbiCursor dbc, const char *fmt, ...)
+{
+    char *cmd = NULL;
+    /*
+     * rpmdb recycles cursors for different purposes, reset if necessary.
+     * This only works as long as fmt is always static (as it is now)
+     */
+    if (dbc->fmt && dbc->fmt != fmt)
+	dbiCursorReset(dbc);
+
+    if (dbc->fmt == NULL) {
+	va_list ap;
+
+	va_start(ap, fmt); 
+	cmd = sqlite3_vmprintf(fmt, ap);
+	va_end(ap);
+	dbc->fmt = fmt;
+    }
+
+    if (dbc->stmt == NULL) {
+	sqlite3_prepare_v2(dbc->sdb, cmd, -1, &dbc->stmt, NULL);
+    } else {
+	sqlite3_reset(dbc->stmt);
+    }
+    sqlite3_free(cmd);
+
+    return dbiCursorResult(dbc);
+}
+
+static int dbiCursorBindPkg(dbiCursor dbc, unsigned int hnum,
+				void *blob, unsigned int bloblen)
+{
+    int rc = sqlite3_bind_int(dbc->stmt, 1, hnum);
+    if (blob) {
+	if (!rc)
+	    rc = sqlite3_bind_blob(dbc->stmt, 2, blob, bloblen, NULL);
+    }
+    return dbiCursorResult(dbc);
+}
+
+static int dbiCursorBindIdx(dbiCursor dbc, const void *key, int keylen,
+				dbiIndexItem rec)
+{
+    int rc;
+    if (dbc->ctype == SQLITE_TEXT) {
+	rc = sqlite3_bind_text(dbc->stmt, 1, key, keylen, NULL);
+    } else {
+	rc = sqlite3_bind_blob(dbc->stmt, 1, key, keylen, NULL);
+    }
+
+    if (rec) {
+	if (!rc)
+	    rc = sqlite3_bind_int(dbc->stmt, 2, rec->hdrNum);
+	if (!rc)
+	    rc = sqlite3_bind_int(dbc->stmt, 3, rec->tagNum);
+    }
+
+    return dbiCursorResult(dbc);
+}
+
+static int sqlite_init(rpmdb rdb, const char * dbhome)
+{
+    int rc = 0;
+    char *dbfile = NULL;
+
+    if (rdb->db_dbenv == NULL) {
+	dbfile = rpmGenPath(dbhome, "rpmdb.sqlite", NULL);
+	sqlite3 *sdb = NULL;
+	int xx, flags = 0;
+	int retry_open = 1;
+	if ((rdb->db_mode & O_ACCMODE) == O_RDONLY)
+	    flags |= SQLITE_OPEN_READONLY;
+	else
+	    flags |= (SQLITE_OPEN_READWRITE | SQLITE_OPEN_CREATE);
+
+	while (retry_open--) {
+	    xx = sqlite3_open_v2(dbfile, &sdb, flags, NULL);
+	    /* Attempt to create if missing, discarding OPEN_READONLY (!) */
+	    if (xx == SQLITE_CANTOPEN && (flags & SQLITE_OPEN_READONLY)) {
+		flags &= ~SQLITE_OPEN_READONLY;
+		flags |= (SQLITE_OPEN_READWRITE | SQLITE_OPEN_CREATE);
+		retry_open++;
+	    }
+	}
+
+	if (xx != SQLITE_OK) {
+	    rpmlog(RPMLOG_ERR, _("Unable to open sqlite database %s: %s\n"),
+		    dbfile, sqlite3_errmsg(sdb));
+	    rc = 1;
+	    goto exit;
+	}
+	sqlite3_busy_timeout(sdb, sleep_ms);
+
+	if (rdb->db_flags & RPMDB_FLAG_REBUILD) {
+	    sqlexec(sdb, "PRAGMA journal_mode = OFF");
+	    sqlexec(sdb, "PRAGMA locking_mode = EXCLUSIVE");
+	}
+
+	rdb->db_dbenv = sdb;
+	rdb->db_descr = xstrdup("sqlite");
+    }
+    rdb->db_opens++;
+
+exit:
+    free(dbfile);
+    return rc;
+}
+
+static int sqlite_fini(rpmdb rdb)
+{
+    int rc = 0;
+    if (rdb) {
+	sqlite3 *sdb = rdb->db_dbenv;
+	if (rdb->db_opens > 1) {
+	    rdb->db_opens--;
+	} else {
+	    if (sqlite3_db_readonly(sdb, NULL) == 0) {
+		sqlexec(sdb, "PRAGMA optimize");
+	    }
+	    int xx = sqlite3_close(sdb);
+	    rc = (xx != SQLITE_OK);
+	}
+    }
+
+    return rc;
+}
+
+static int sqlexec(sqlite3 *sdb, const char *fmt, ...)
+{
+    int rc = 0;
+    char *cmd = NULL;
+    char *err = NULL;
+    va_list ap;
+
+    va_start(ap, fmt);
+    cmd = sqlite3_vmprintf(fmt, ap);
+    va_end(ap);
+
+    /* sqlite3_exec() doesn't seeem to honor sqlite3_busy_timeout() */
+    while ((rc = sqlite3_exec(sdb, cmd, NULL, NULL, &err)) == SQLITE_BUSY) {
+	usleep(sleep_ms);
+    }
+
+    if (rc)
+	rpmlog(RPMLOG_ERR, "sqlite failure: %s: %s\n", cmd, err);
+    else
+	rpmlog(RPMLOG_DEBUG, "%s: %d\n", cmd, rc);
+
+    sqlite3_free(cmd);
+
+    return rc ? RPMRC_FAIL : RPMRC_OK;
+}
+
+static int init_table(dbiIndex dbi, rpmTagVal tag)
+{
+    int rc = 0;
+
+    if (dbi->dbi_type == DBI_PRIMARY) {
+	rc = sqlexec(dbi->dbi_db,
+			"CREATE TABLE IF NOT EXISTS '%q' ("
+			    "hnum INTEGER PRIMARY KEY NOT NULL,"
+			    "blob BLOB NOT NULL"
+			")",
+			dbi->dbi_file);
+    } else {
+	const char *keytype = (rpmTagGetClass(tag) == RPM_STRING_CLASS) ?
+				"TEXT" : "BLOB";
+	rc = sqlexec(dbi->dbi_db,
+			"CREATE TABLE IF NOT EXISTS '%q' ("
+			    "key '%q' NOT NULL, "
+			    "hnum INTEGER NOT NULL, "
+			    "idx INTEGER NOT NULL, "
+			    "FOREIGN KEY (hnum) REFERENCES 'Packages'(hnum)"
+			")",
+			dbi->dbi_file, keytype);
+    }
+
+    return rc;
+}
+
+static int init_index(dbiIndex dbi, rpmTagVal tag)
+{
+    int rc = 0;
+    if (dbi->dbi_type == DBI_SECONDARY) {
+	rc = sqlexec(dbi->dbi_db,
+		    "CREATE INDEX IF NOT EXISTS '%q_idx' ON '%q'(key ASC)",
+		    dbi->dbi_file, dbi->dbi_file);
+    }
+    return rc;
+}
+
+static int sqlite_Open(rpmdb rdb, rpmDbiTagVal rpmtag, dbiIndex * dbip, int flags)
+{
+    int rc = sqlite_init(rdb, rpmdbHome(rdb));
+
+    dbiIndex dbi = dbiNew(rdb, rpmtag);
+    dbi->dbi_db = rdb->db_dbenv;
+
+    if (sqlite3_db_readonly(rdb->db_dbenv, NULL) == 0) {
+	if (!rc)
+	    rc = init_table(dbi, rpmtag);
+
+	if (!rc)
+	    rc = init_index(dbi, rpmtag);
+    }
+
+    if (!rc && dbi->dbi_type == DBI_PRIMARY) {
+	unsigned int hnum = 0;
+	if (sqlite_pkgdbNew(dbi, NULL, &hnum) == 0 && hnum == 1) {
+	    dbi->dbi_flags |= DBI_CREATED;
+	}
+    }
+
+    if (dbip)
+	*dbip = dbi;
+    else
+	dbiFree(dbi);
+
+    return rc;
+}
+
+static int sqlite_Close(dbiIndex dbi, unsigned int flags)
+{
+    sqlite_fini(dbi->dbi_rpmdb);
+    dbiFree(dbi);
+    return 0;
+}
+
+static int sqlite_Verify(dbiIndex dbi, unsigned int flags)
+{
+    int rc = RPMRC_FAIL;
+    sqlite3_stmt *s = NULL;
+    const char *cmd = "PRAGMA integrity_check";
+
+    if (dbi->dbi_type == DBI_SECONDARY)
+	return RPMRC_OK;
+
+    if (sqlite3_prepare_v2(dbi->dbi_db, cmd, -1, &s, NULL) == SQLITE_OK) {
+	while (sqlite3_step(s) == SQLITE_ROW) {
+	    rc = RPMRC_OK;
+	}
+	sqlite3_finalize(s);
+    } else {
+	rpmlog(RPMLOG_ERR, "%s: %s\n", cmd, sqlite3_errmsg(dbi->dbi_db));
+    }
+
+    return rc;
+}
+
+static void sqlite_SetFSync(rpmdb rdb, int enable)
+{
+    sqlexec(rdb->db_dbenv,
+	    "PRAGMA synchronous = %s", enable ? "NORMAL" : "OFF");
+}
+
+static int sqlite_Ctrl(rpmdb rdb, dbCtrlOp ctrl)
+{
+    int rc = 0;
+
+    switch (ctrl) {
+    case DB_CTRL_LOCK_RW:
+	rc = sqlexec(rdb->db_dbenv, "SAVEPOINT 'rwlock'");
+	break;
+    case DB_CTRL_UNLOCK_RW:
+	rc = sqlexec(rdb->db_dbenv, "RELEASE 'rwlock'");
+	break;
+    default:
+	break;
+    }
+
+    return rc;
+}
+
+static dbiCursor sqlite_CursorInit(dbiIndex dbi, unsigned int flags)
+{
+    dbiCursor dbc = xcalloc(1, sizeof(*dbc));
+    dbc->sdb = dbi->dbi_db;
+    dbc->flags = flags;
+    dbc->tag = rpmTagGetValue(dbi->dbi_file);
+    if (rpmTagGetClass(dbc->tag) == RPM_STRING_CLASS) {
+	dbc->ctype = SQLITE_TEXT;
+    } else {
+	dbc->ctype = SQLITE_BLOB;
+    }
+    if (dbc->flags & DBC_WRITE)
+	sqlexec(dbc->sdb, "SAVEPOINT '%s'", dbi->dbi_file);
+    return dbc;
+}
+
+static dbiCursor sqlite_CursorFree(dbiIndex dbi, dbiCursor dbc)
+{
+    if (dbc) {
+	if (dbc->flags & DBC_WRITE)
+	    sqlexec(dbc->sdb, "RELEASE '%s'", dbi->dbi_file);
+	if (dbc->stmt)
+	    sqlite3_finalize(dbc->stmt);
+	free(dbc);
+    }
+    return NULL;
+}
+
+static rpmRC sqlite_pkgdbNew(dbiIndex dbi, dbiCursor dbc,  unsigned int *hdrNum)
+{
+    dbiCursor c = dbiCursorInit(dbi, 0);
+    int rc = dbiCursorPrep(c, "SELECT MAX(hnum) FROM '%q'", dbi->dbi_file);
+
+    if (!rc) {
+	while ((rc = sqlite3_step(c->stmt)) == SQLITE_ROW) {
+	    *hdrNum = sqlite3_column_int(c->stmt, 0) + 1;
+	}
+    }
+    rc = dbiCursorResult(c);
+    dbiCursorFree(dbi, c);
+
+    return rc;
+}
+
+static rpmRC sqlite_pkgdbPut(dbiIndex dbi, dbiCursor dbc,  unsigned int hdrNum, unsigned char *hdrBlob, unsigned int hdrLen)
+{
+    int rc = dbiCursorPrep(dbc, "INSERT OR REPLACE INTO '%q' VALUES(?, ?)",
+			    dbi->dbi_file);
+
+    if (!rc)
+	rc = dbiCursorBindPkg(dbc, hdrNum, hdrBlob, hdrLen);
+
+    if (!rc)
+	while ((rc = sqlite3_step(dbc->stmt)) == SQLITE_ROW) {};
+
+    return dbiCursorResult(dbc);
+}
+
+static rpmRC sqlite_pkgdbDel(dbiIndex dbi, dbiCursor dbc,  unsigned int hdrNum)
+{
+    int rc = dbiCursorPrep(dbc, "DELETE FROM '%q' WHERE hnum=?;",
+			    dbi->dbi_file);
+
+    if (!rc)
+	rc = dbiCursorBindPkg(dbc, hdrNum, NULL, 0);
+
+    if (!rc)
+	while ((rc = sqlite3_step(dbc->stmt)) == SQLITE_ROW) {};
+
+    return dbiCursorResult(dbc);
+}
+
+static rpmRC sqlite_pkgdbByKey(dbiIndex dbi, dbiCursor dbc, unsigned int hdrNum, unsigned char **hdrBlob, unsigned int *hdrLen)
+{
+    int rc = dbiCursorPrep(dbc, "SELECT hnum, blob from '%q' where hnum=?",
+				dbi->dbi_file);
+
+    if (!rc)
+	rc = dbiCursorBindPkg(dbc, hdrNum, NULL, 0);
+
+    if (!rc) {
+	while ((rc = sqlite3_step(dbc->stmt)) == SQLITE_ROW) {
+	    *hdrLen = sqlite3_column_bytes(dbc->stmt, 1);
+	    *hdrBlob = memcpy(xmalloc(*hdrLen),
+				sqlite3_column_blob(dbc->stmt, 1), *hdrLen);
+	}
+    }
+
+    return dbiCursorResult(dbc);
+}
+
+static rpmRC sqlite_pkgdbIter(dbiIndex dbi, dbiCursor dbc,
+				unsigned char **hdrBlob, unsigned int *hdrLen)
+{
+    int rc = RPMRC_OK;
+    if (dbc->stmt == NULL) {
+	rc = dbiCursorPrep(dbc, "SELECT hnum from '%q'", dbi->dbi_file);
+    }
+
+    if (!rc)
+	rc = sqlite3_step(dbc->stmt);
+
+    if (rc == SQLITE_ROW) {
+	int hnum = sqlite3_column_int(dbc->stmt, 0);
+	dbiCursor kc = dbiCursorInit(dbi, 0);
+	rc = sqlite_pkgdbByKey(dbi, kc, hnum, hdrBlob, hdrLen);
+	dbiCursorFree(dbi, kc);
+    } else if (rc == SQLITE_DONE) {
+	rc = RPMRC_NOTFOUND;
+    } else {
+	rc = dbiCursorResult(dbc);
+    }
+
+    return rc;
+}
+
+static rpmRC sqlite_pkgdbGet(dbiIndex dbi, dbiCursor dbc, unsigned int hdrNum, unsigned char **hdrBlob, unsigned int *hdrLen)
+{
+    int rc;
+
+    if (hdrNum) {
+	rc = sqlite_pkgdbByKey(dbi, dbc, hdrNum, hdrBlob, hdrLen);
+    } else {
+	rc = sqlite_pkgdbIter(dbi, dbc, hdrBlob, hdrLen);
+    }
+
+    return rc;
+}
+
+static unsigned int sqlite_pkgdbKey(dbiIndex dbi, dbiCursor dbc)
+{
+    return sqlite3_column_int(dbc->stmt, 0);
+}
+
+static rpmRC sqlite_idxdbByKey(dbiIndex dbi, dbiCursor dbc, const char *keyp, size_t keylen, dbiIndexSet *set)
+{
+    int rc = dbiCursorPrep(dbc, "SELECT key, hnum, idx from '%q' where key=?",
+			dbi->dbi_file);
+
+    if (!rc)
+	rc = dbiCursorBindIdx(dbc, keyp, keylen, NULL);
+
+    if (!rc) {
+	while ((rc = sqlite3_step(dbc->stmt)) == SQLITE_ROW) {
+	    unsigned int hnum = sqlite3_column_int(dbc->stmt, 1);
+	    unsigned int tnum = sqlite3_column_int(dbc->stmt, 2);
+
+	    if (*set == NULL)
+		*set = dbiIndexSetNew(5);
+	    dbiIndexSetAppendOne(*set, hnum, tnum, 0);
+	}
+    }
+
+    if (rc == SQLITE_DONE) {
+	if (*set)
+	    dbiIndexSetSort(*set);
+	rc = (*set) ? RPMRC_OK : RPMRC_NOTFOUND;
+    } else {
+	rc = dbiCursorResult(dbc);
+    }
+
+    return rc;
+}
+
+static rpmRC sqlite_idxdbIter(dbiIndex dbi, dbiCursor dbc, const char *keyp, size_t keylen, dbiIndexSet *set, int searchType)
+{
+    int rc = RPMRC_OK;
+
+    if (dbc->stmt == NULL) {
+	if (searchType == DBC_PREFIX_SEARCH) {
+	    rc = dbiCursorPrep(dbc, "SELECT DISTINCT key from '%q' "
+				    "WHERE key LIKE '%q%%' "
+				    "AND LENGTH(key) >= %d "
+				    "ORDER BY key",
+				    dbi->dbi_file, keyp, keylen);
+	} else {
+	    rc = dbiCursorPrep(dbc, "SELECT DISTINCT key from '%q' "
+				    "ORDER BY key",
+				dbi->dbi_file);
+	}
+    }
+
+    if (!rc)
+	rc = sqlite3_step(dbc->stmt);
+
+    if (rc == SQLITE_ROW) {
+	dbiCursor kc = dbiCursorInit(dbi, 0);
+	if (dbc->ctype == SQLITE_TEXT) {
+	    dbc->key = sqlite3_column_text(dbc->stmt, 0);
+	} else {
+	    dbc->key = sqlite3_column_blob(dbc->stmt, 0);
+	}
+	dbc->keylen = sqlite3_column_bytes(dbc->stmt, 0);
+	rc = sqlite_idxdbByKey(dbi, kc, dbc->key, dbc->keylen, set);
+	dbiCursorFree(dbi, kc);
+	rc = RPMRC_OK;
+    } else if (rc == SQLITE_DONE) {
+	if (searchType == DBC_PREFIX_SEARCH && (*set))
+	    rc = RPMRC_OK;
+	else
+	    rc = RPMRC_NOTFOUND;
+    } else {
+	rc = dbiCursorResult(dbc);
+    }
+
+    return rc;
+}
+
+static rpmRC sqlite_idxdbGet(dbiIndex dbi, dbiCursor dbc, const char *keyp, size_t keylen, dbiIndexSet *set, int searchType)
+{
+    int rc;
+    if (keyp && searchType != DBC_PREFIX_SEARCH) {
+	rc = sqlite_idxdbByKey(dbi, dbc, keyp, keylen, set);
+    } else {
+	rc = sqlite_idxdbIter(dbi, dbc, keyp, keylen, set, searchType);
+    }
+
+    return rc;
+}
+
+static rpmRC sqlite_idxdbPut(dbiIndex dbi, dbiCursor dbc, const char *keyp, size_t keylen, dbiIndexItem rec)
+{
+    int rc = dbiCursorPrep(dbc, "INSERT INTO '%q' VALUES(?, ?, ?)",
+			dbi->dbi_file);
+
+    if (!rc)
+	rc = dbiCursorBindIdx(dbc, keyp, keylen, rec);
+
+    if (!rc)
+	while ((rc = sqlite3_step(dbc->stmt)) == SQLITE_ROW) {};
+
+    return dbiCursorResult(dbc);
+}
+
+static rpmRC sqlite_idxdbDel(dbiIndex dbi, dbiCursor dbc, const char *keyp, size_t keylen, dbiIndexItem rec)
+{
+    int rc = dbiCursorPrep(dbc,
+			"DELETE FROM '%q' WHERE key=? AND hnum=? AND idx=?",
+			dbi->dbi_file);
+
+
+    if (!rc)
+	rc = dbiCursorBindIdx(dbc, keyp, keylen, rec);
+
+    if (!rc)
+	while ((rc = sqlite3_step(dbc->stmt)) == SQLITE_ROW) {};
+
+    return dbiCursorResult(dbc);
+}
+
+static const void * sqlite_idxdbKey(dbiIndex dbi, dbiCursor dbc, unsigned int *keylen)
+{
+    const void *key = NULL;
+    if (dbc) {
+	key = dbc->key;
+	if (key && keylen)
+	    *keylen = dbc->keylen;
+    }
+    return key;
+}
+
+
+
+struct rpmdbOps_s sqlite_dbops = {
+    .open	= sqlite_Open,
+    .close	= sqlite_Close,
+    .verify	= sqlite_Verify,
+    .setFSync	= sqlite_SetFSync,
+    .ctrl	= sqlite_Ctrl,
+
+    .cursorInit	= sqlite_CursorInit,
+    .cursorFree	= sqlite_CursorFree,
+
+    .pkgdbNew	= sqlite_pkgdbNew,
+    .pkgdbPut	= sqlite_pkgdbPut,
+    .pkgdbDel	= sqlite_pkgdbDel,
+    .pkgdbGet	= sqlite_pkgdbGet,
+    .pkgdbKey	= sqlite_pkgdbKey,
+
+    .idxdbGet	= sqlite_idxdbGet,
+    .idxdbPut	= sqlite_idxdbPut,
+    .idxdbDel	= sqlite_idxdbDel,
+    .idxdbKey	= sqlite_idxdbKey
+};
+
diff --git a/macros.in b/macros.in
index fe9803aad..ff9270ac8 100644
--- a/macros.in
+++ b/macros.in
@@ -618,6 +618,7 @@ package or when debugging this package.\
 # bdb Berkeley DB
 # lmdb Lightning Memory-mapped Database
 # ndb new data base format
+# sqlite Sqlite database
 #
 %_db_backend	      bdb
 
