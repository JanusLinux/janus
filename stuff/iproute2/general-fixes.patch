diff -ruN iproute2-4.20.0/bridge/fdb.c iproute2-4.20.0_b/bridge/fdb.c
--- iproute2-4.20.0/bridge/fdb.c	2019-01-07 21:24:02.000000000 +0300
+++ iproute2-4.20.0_b/bridge/fdb.c	2019-03-14 15:27:08.764797501 +0300
@@ -18,7 +18,6 @@
 #include <net/if.h>
 #include <netinet/in.h>
 #include <linux/if_bridge.h>
-#include <linux/if_ether.h>
 #include <linux/neighbour.h>
 #include <string.h>
 #include <limits.h>
diff -ruN iproute2-4.20.0/bridge/mdb.c iproute2-4.20.0_b/bridge/mdb.c
--- iproute2-4.20.0/bridge/mdb.c	2019-01-07 21:24:02.000000000 +0300
+++ iproute2-4.20.0_b/bridge/mdb.c	2019-03-14 15:27:08.764797501 +0300
@@ -11,7 +11,6 @@
 #include <net/if.h>
 #include <netinet/in.h>
 #include <linux/if_bridge.h>
-#include <linux/if_ether.h>
 #include <string.h>
 #include <arpa/inet.h>
 
diff -ruN iproute2-4.20.0/bridge/vlan.c iproute2-4.20.0_b/bridge/vlan.c
--- iproute2-4.20.0/bridge/vlan.c	2019-01-07 21:24:02.000000000 +0300
+++ iproute2-4.20.0_b/bridge/vlan.c	2019-03-14 15:27:08.764797501 +0300
@@ -7,7 +7,6 @@
 #include <net/if.h>
 #include <netinet/in.h>
 #include <linux/if_bridge.h>
-#include <linux/if_ether.h>
 #include <string.h>
 
 #include "json_print.h"
diff -ruN iproute2-4.20.0/configure iproute2-4.20.0_b/configure
--- iproute2-4.20.0/configure	2019-01-07 21:24:02.000000000 +0300
+++ iproute2-4.20.0_b/configure	2019-03-14 15:27:10.018130802 +0300
@@ -384,7 +384,7 @@
 check_selinux
 
 echo -n "ELF support: "
-check_elf
+echo "no"
 
 echo -n "libmnl support: "
 check_mnl
diff -ruN iproute2-4.20.0/include/uapi/linux/if_bridge.h iproute2-4.20.0_b/include/uapi/linux/if_bridge.h
--- iproute2-4.20.0/include/uapi/linux/if_bridge.h	2019-01-07 21:24:02.000000000 +0300
+++ iproute2-4.20.0_b/include/uapi/linux/if_bridge.h	2019-03-14 15:27:08.764797501 +0300
@@ -14,8 +14,9 @@
 #ifndef _LINUX_IF_BRIDGE_H
 #define _LINUX_IF_BRIDGE_H
 
+#include <netinet/if_ether.h>
+
 #include <linux/types.h>
-#include <linux/if_ether.h>
 #include <linux/in6.h>
 
 #define SYSFS_BRIDGE_ATTR	"bridge"
diff -ruN iproute2-4.20.0/include/uapi/linux/if_tunnel.h iproute2-4.20.0_b/include/uapi/linux/if_tunnel.h
--- iproute2-4.20.0/include/uapi/linux/if_tunnel.h	2019-01-07 21:24:02.000000000 +0300
+++ iproute2-4.20.0_b/include/uapi/linux/if_tunnel.h	2019-03-14 15:27:08.764797501 +0300
@@ -2,8 +2,9 @@
 #ifndef _IF_TUNNEL_H_
 #define _IF_TUNNEL_H_
 
+#include <net/if.h>
+
 #include <linux/types.h>
-#include <linux/if.h>
 #include <linux/ip.h>
 #include <linux/in6.h>
 #include <asm/byteorder.h>
diff -ruN iproute2-4.20.0/include/uapi/linux/ip6_tunnel.h iproute2-4.20.0_b/include/uapi/linux/ip6_tunnel.h
--- iproute2-4.20.0/include/uapi/linux/ip6_tunnel.h	2019-01-07 21:24:02.000000000 +0300
+++ iproute2-4.20.0_b/include/uapi/linux/ip6_tunnel.h	2019-03-14 15:27:08.764797501 +0300
@@ -2,8 +2,9 @@
 #ifndef _IP6_TUNNEL_H
 #define _IP6_TUNNEL_H
 
+#include <net/if.h>		/* For IFNAMSIZ. */
+
 #include <linux/types.h>
-#include <linux/if.h>		/* For IFNAMSIZ. */
 #include <linux/in6.h>		/* For struct in6_addr. */
 
 #define IPV6_TLV_TNL_ENCAP_LIMIT 4
diff -ruN iproute2-4.20.0/include/uapi/linux/netdevice.h iproute2-4.20.0_b/include/uapi/linux/netdevice.h
--- iproute2-4.20.0/include/uapi/linux/netdevice.h	2019-01-07 21:24:02.000000000 +0300
+++ iproute2-4.20.0_b/include/uapi/linux/netdevice.h	2019-03-14 15:27:08.764797501 +0300
@@ -26,7 +26,8 @@
 #ifndef _LINUX_NETDEVICE_H
 #define _LINUX_NETDEVICE_H
 
-#include <linux/if.h>
+#include <net/if.h>
+
 #include <linux/if_ether.h>
 #include <linux/if_packet.h>
 #include <linux/if_link.h>
diff -ruN iproute2-4.20.0/ip/ip6tunnel.c iproute2-4.20.0_b/ip/ip6tunnel.c
--- iproute2-4.20.0/ip/ip6tunnel.c	2019-01-07 21:24:02.000000000 +0300
+++ iproute2-4.20.0_b/ip/ip6tunnel.c	2019-03-14 15:27:08.764797501 +0300
@@ -27,8 +27,8 @@
 #include <sys/socket.h>
 #include <arpa/inet.h>
 #include <sys/ioctl.h>
+#include <net/if.h>
 #include <linux/ip.h>
-#include <linux/if.h>
 #include <linux/if_arp.h>
 #include <linux/if_tunnel.h>
 #include <linux/ip6_tunnel.h>
diff -ruN iproute2-4.20.0/ip/ipl2tp.c iproute2-4.20.0_b/ip/ipl2tp.c
--- iproute2-4.20.0/ip/ipl2tp.c	2019-01-07 21:24:02.000000000 +0300
+++ iproute2-4.20.0_b/ip/ipl2tp.c	2019-03-14 15:27:08.764797501 +0300
@@ -19,7 +19,7 @@
 #include <sys/socket.h>
 #include <arpa/inet.h>
 #include <sys/ioctl.h>
-#include <linux/if.h>
+#include <net/if.h>
 #include <linux/if_arp.h>
 #include <linux/ip.h>
 
diff -ruN iproute2-4.20.0/ip/iplink_hsr.c iproute2-4.20.0_b/ip/iplink_hsr.c
--- iproute2-4.20.0/ip/iplink_hsr.c	2019-01-07 21:24:02.000000000 +0300
+++ iproute2-4.20.0_b/ip/iplink_hsr.c	2019-03-14 15:27:08.764797501 +0300
@@ -15,7 +15,7 @@
 #include <stdlib.h>
 #include <string.h>
 #include <sys/socket.h>  /* Needed by linux/if.h for some reason */
-#include <linux/if.h>
+#include <net/if.h>
 #include <linux/if_arp.h>
 #include "rt_names.h"
 #include "utils.h"
diff -ruN iproute2-4.20.0/ip/ipmaddr.c iproute2-4.20.0_b/ip/ipmaddr.c
--- iproute2-4.20.0/ip/ipmaddr.c	2019-01-07 21:24:02.000000000 +0300
+++ iproute2-4.20.0_b/ip/ipmaddr.c	2019-03-14 15:27:08.768130834 +0300
@@ -19,9 +19,9 @@
 #include <netinet/in.h>
 #include <arpa/inet.h>
 #include <string.h>
+#include <net/if.h>
 
 #include <linux/netdevice.h>
-#include <linux/if.h>
 #include <linux/if_arp.h>
 #include <linux/sockios.h>
 
diff -ruN iproute2-4.20.0/ip/ipmroute.c iproute2-4.20.0_b/ip/ipmroute.c
--- iproute2-4.20.0/ip/ipmroute.c	2019-01-07 21:24:02.000000000 +0300
+++ iproute2-4.20.0_b/ip/ipmroute.c	2019-03-14 15:27:08.768130834 +0300
@@ -20,9 +20,9 @@
 #include <netinet/in.h>
 #include <arpa/inet.h>
 #include <string.h>
+#include <net/if.h>
 
 #include <linux/netdevice.h>
-#include <linux/if.h>
 #include <linux/if_arp.h>
 #include <linux/sockios.h>
 
diff -ruN iproute2-4.20.0/ip/iptuntap.c iproute2-4.20.0_b/ip/iptuntap.c
--- iproute2-4.20.0/ip/iptuntap.c	2019-01-07 21:24:02.000000000 +0300
+++ iproute2-4.20.0_b/ip/iptuntap.c	2019-03-14 15:27:08.768130834 +0300
@@ -18,7 +18,6 @@
 #include <sys/socket.h>
 #include <arpa/inet.h>
 #include <sys/ioctl.h>
-#include <linux/if.h>
 #include <linux/if_tun.h>
 #include <linux/if_arp.h>
 #include <pwd.h>
diff -ruN iproute2-4.20.0/ip/tunnel.c iproute2-4.20.0_b/ip/tunnel.c
--- iproute2-4.20.0/ip/tunnel.c	2019-01-07 21:24:02.000000000 +0300
+++ iproute2-4.20.0_b/ip/tunnel.c	2019-03-14 15:27:08.768130834 +0300
@@ -30,7 +30,7 @@
 #include <sys/socket.h>
 #include <sys/ioctl.h>
 #include <netinet/in.h>
-#include <linux/if.h>
+#include <net/if.h>
 #include <linux/ip.h>
 #include <linux/if_tunnel.h>
 #include <linux/if_arp.h>
diff -ruN iproute2-4.20.0/Makefile iproute2-4.20.0_b/Makefile
--- iproute2-4.20.0/Makefile	2019-01-07 21:24:02.000000000 +0300
+++ iproute2-4.20.0_b/Makefile	2019-03-14 15:27:08.984797495 +0300
@@ -22,7 +22,6 @@
 HDRDIR?=$(PREFIX)/include/iproute2
 DOCDIR?=$(DATADIR)/doc/iproute2
 MANDIR?=$(DATADIR)/man
-ARPDDIR?=/var/lib/arpd
 KERNEL_INCLUDE?=/usr/include
 BASH_COMPDIR?=$(DATADIR)/bash-completion/completions
 
@@ -31,7 +30,7 @@
 
 SHARED_LIBS = y
 
-DEFINES= -DRESOLVE_HOSTNAMES -DLIBDIR=\"$(LIBDIR)\"
+DEFINES= -DRESOLVE_HOSTNAMES -DLIBDIR=\"$(LIBDIR)\" -DDATADIR=\"$(DATADIR)\"
 ifneq ($(SHARED_LIBS),y)
 DEFINES+= -DNO_SHARED_LIBS
 endif
@@ -90,7 +89,6 @@
 install: all
 	install -m 0755 -d $(DESTDIR)$(SBINDIR)
 	install -m 0755 -d $(DESTDIR)$(CONFDIR)
-	install -m 0755 -d $(DESTDIR)$(ARPDDIR)
 	install -m 0755 -d $(DESTDIR)$(HDRDIR)
 	install -m 0755 -d $(DESTDIR)$(DOCDIR)/examples
 	install -m 0755 -d $(DESTDIR)$(DOCDIR)/examples/diffserv
diff -ruN iproute2-4.20.0/Makefile.orig iproute2-4.20.0_b/Makefile.orig
--- iproute2-4.20.0/Makefile.orig	1970-01-01 03:00:00.000000000 +0300
+++ iproute2-4.20.0_b/Makefile.orig	2019-01-07 21:24:02.000000000 +0300
@@ -0,0 +1,128 @@
+# SPDX-License-Identifier: GPL-2.0
+# Top level Makefile for iproute2
+
+ifeq ("$(origin V)", "command line")
+VERBOSE = $(V)
+endif
+ifndef VERBOSE
+VERBOSE = 0
+endif
+
+ifeq ($(VERBOSE),0)
+MAKEFLAGS += --no-print-directory
+endif
+
+PREFIX?=/usr
+LIBDIR?=$(PREFIX)/lib
+SBINDIR?=/sbin
+CONFDIR?=/etc/iproute2
+NETNS_RUN_DIR?=/var/run/netns
+NETNS_ETC_DIR?=/etc/netns
+DATADIR?=$(PREFIX)/share
+HDRDIR?=$(PREFIX)/include/iproute2
+DOCDIR?=$(DATADIR)/doc/iproute2
+MANDIR?=$(DATADIR)/man
+ARPDDIR?=/var/lib/arpd
+KERNEL_INCLUDE?=/usr/include
+BASH_COMPDIR?=$(DATADIR)/bash-completion/completions
+
+# Path to db_185.h include
+DBM_INCLUDE:=$(DESTDIR)/usr/include
+
+SHARED_LIBS = y
+
+DEFINES= -DRESOLVE_HOSTNAMES -DLIBDIR=\"$(LIBDIR)\"
+ifneq ($(SHARED_LIBS),y)
+DEFINES+= -DNO_SHARED_LIBS
+endif
+
+DEFINES+=-DCONFDIR=\"$(CONFDIR)\" \
+         -DNETNS_RUN_DIR=\"$(NETNS_RUN_DIR)\" \
+         -DNETNS_ETC_DIR=\"$(NETNS_ETC_DIR)\"
+
+#options for decnet
+ADDLIB+=dnet_ntop.o dnet_pton.o
+
+#options for ipx
+ADDLIB+=ipx_ntop.o ipx_pton.o
+
+#options for mpls
+ADDLIB+=mpls_ntop.o mpls_pton.o
+
+CC := gcc
+HOSTCC ?= $(CC)
+DEFINES += -D_GNU_SOURCE
+# Turn on transparent support for LFS
+DEFINES += -D_FILE_OFFSET_BITS=64 -D_LARGEFILE_SOURCE -D_LARGEFILE64_SOURCE
+CCOPTS = -O2
+WFLAGS := -Wall -Wstrict-prototypes  -Wmissing-prototypes
+WFLAGS += -Wmissing-declarations -Wold-style-definition -Wformat=2
+
+CFLAGS := $(WFLAGS) $(CCOPTS) -I../include -I../include/uapi $(DEFINES) $(CFLAGS)
+YACCFLAGS = -d -t -v
+
+SUBDIRS=lib ip tc bridge misc netem genl tipc devlink rdma man
+
+LIBNETLINK=../lib/libutil.a ../lib/libnetlink.a
+LDLIBS += $(LIBNETLINK)
+
+all: config.mk
+	@set -e; \
+	for i in $(SUBDIRS); \
+	do echo; echo $$i; $(MAKE) $(MFLAGS) -C $$i; done
+
+help:
+	@echo "Make Targets:"
+	@echo " all                 - build binaries"
+	@echo " clean               - remove products of build"
+	@echo " distclean           - remove configuration and build"
+	@echo " install             - install binaries on local machine"
+	@echo " check               - run tests"
+	@echo " cscope              - build cscope database"
+	@echo " snapshot            - generate version number header"
+	@echo ""
+	@echo "Make Arguments:"
+	@echo " V=[0|1]             - set build verbosity level"
+
+config.mk:
+	sh configure $(KERNEL_INCLUDE)
+
+install: all
+	install -m 0755 -d $(DESTDIR)$(SBINDIR)
+	install -m 0755 -d $(DESTDIR)$(CONFDIR)
+	install -m 0755 -d $(DESTDIR)$(ARPDDIR)
+	install -m 0755 -d $(DESTDIR)$(HDRDIR)
+	install -m 0755 -d $(DESTDIR)$(DOCDIR)/examples
+	install -m 0755 -d $(DESTDIR)$(DOCDIR)/examples/diffserv
+	install -m 0644 README.iproute2+tc $(shell find examples -maxdepth 1 -type f) \
+		$(DESTDIR)$(DOCDIR)/examples
+	install -m 0644 $(shell find examples/diffserv -maxdepth 1 -type f) \
+		$(DESTDIR)$(DOCDIR)/examples/diffserv
+	@for i in $(SUBDIRS);  do $(MAKE) -C $$i install; done
+	install -m 0644 $(shell find etc/iproute2 -maxdepth 1 -type f) $(DESTDIR)$(CONFDIR)
+	install -m 0755 -d $(DESTDIR)$(BASH_COMPDIR)
+	install -m 0644 bash-completion/tc $(DESTDIR)$(BASH_COMPDIR)
+	install -m 0644 include/bpf_elf.h $(DESTDIR)$(HDRDIR)
+
+snapshot:
+	echo "static const char SNAPSHOT[] = \""`date +%y%m%d`"\";" \
+		> include/SNAPSHOT.h
+
+clean:
+	@for i in $(SUBDIRS) testsuite; \
+	do $(MAKE) $(MFLAGS) -C $$i clean; done
+
+clobber:
+	touch config.mk
+	$(MAKE) $(MFLAGS) clean
+	rm -f config.mk cscope.*
+
+distclean: clobber
+
+check: all
+	cd testsuite && $(MAKE) && $(MAKE) alltests
+
+cscope:
+	cscope -b -q -R -Iinclude -sip -slib -smisc -snetem -stc
+
+.EXPORT_ALL_VARIABLES:
diff -ruN iproute2-4.20.0/misc/Makefile iproute2-4.20.0_b/misc/Makefile
--- iproute2-4.20.0/misc/Makefile	2019-01-07 21:24:02.000000000 +0300
+++ iproute2-4.20.0_b/misc/Makefile	2019-03-14 15:27:28.071463668 +0300
@@ -25,7 +25,7 @@
 	$(QUIET_CC)$(CC) $(CFLAGS) $(CPPFLAGS) $(LDFLAGS) -o rtacct rtacct.c $(LDLIBS) -lm
 
 arpd: arpd.c
-	$(QUIET_CC)$(CC) $(CFLAGS) -I$(DBM_INCLUDE) $(CPPFLAGS) $(LDFLAGS) -o arpd arpd.c $(LDLIBS) -ldb
+	echo "avoid"
 
 ssfilter.c: ssfilter.y
 	$(QUIET_YACC)bison ssfilter.y -o ssfilter.c
diff -ruN iproute2-4.20.0/netem/Makefile iproute2-4.20.0_b/netem/Makefile
--- iproute2-4.20.0/netem/Makefile	2019-01-07 21:24:02.000000000 +0300
+++ iproute2-4.20.0_b/netem/Makefile	2019-03-14 15:27:08.844797498 +0300
@@ -23,9 +23,9 @@
 	$(HOSTCC) $(CCOPTS) -I../include -o $@ $@.c -lm
 
 install: all
-	mkdir -p $(DESTDIR)$(LIBDIR)/tc
+	mkdir -p $(DESTDIR)$(DATADIR)/tc
 	for i in $(DISTDATA); \
-	do install -m 644 $$i $(DESTDIR)$(LIBDIR)/tc; \
+	do install -m 644 $$i $(DESTDIR)$(DATADIR)/tc; \
 	done
 
 clean:
diff -ruN iproute2-4.20.0/netem/Makefile.orig iproute2-4.20.0_b/netem/Makefile.orig
--- iproute2-4.20.0/netem/Makefile.orig	1970-01-01 03:00:00.000000000 +0300
+++ iproute2-4.20.0_b/netem/Makefile.orig	2019-01-07 21:24:02.000000000 +0300
@@ -0,0 +1,32 @@
+# SPDX-License-Identifier: GPL-2.0
+include ../config.mk
+
+DISTGEN = maketable normal pareto paretonormal
+DISTDATA = normal.dist pareto.dist paretonormal.dist experimental.dist
+
+HOSTCC ?= $(CC)
+CCOPTS  = $(CBUILD_CFLAGS)
+LDLIBS += -lm
+
+all: $(DISTGEN) $(DISTDATA)
+
+$(DISTGEN):
+	$(HOSTCC) $(CCOPTS) -I../include -o $@ $@.c -lm
+
+%.dist: %
+	./$* > $@
+
+experimental.dist: maketable experimental.dat
+	./maketable experimental.dat > experimental.dist
+
+stats: stats.c
+	$(HOSTCC) $(CCOPTS) -I../include -o $@ $@.c -lm
+
+install: all
+	mkdir -p $(DESTDIR)$(LIBDIR)/tc
+	for i in $(DISTDATA); \
+	do install -m 644 $$i $(DESTDIR)$(LIBDIR)/tc; \
+	done
+
+clean:
+	rm -f $(DISTDATA) $(DISTGEN)
diff -ruN iproute2-4.20.0/tc/f_flower.c iproute2-4.20.0_b/tc/f_flower.c
--- iproute2-4.20.0/tc/f_flower.c	2019-01-07 21:24:02.000000000 +0300
+++ iproute2-4.20.0_b/tc/f_flower.c	2019-03-14 15:27:08.808130832 +0300
@@ -14,6 +14,7 @@
 #include <unistd.h>
 #include <string.h>
 #include <net/if.h>
+#include <linux/limits.h>
 #include <linux/if_arp.h>
 #include <linux/if_ether.h>
 #include <linux/ip.h>
diff -ruN iproute2-4.20.0/tc/q_netem.c iproute2-4.20.0_b/tc/q_netem.c
--- iproute2-4.20.0/tc/q_netem.c	2019-01-07 21:24:02.000000000 +0300
+++ iproute2-4.20.0_b/tc/q_netem.c	2019-03-14 15:27:08.844797498 +0300
@@ -101,7 +101,7 @@
 	char *line = NULL;
 	char name[128];
 
-	snprintf(name, sizeof(name), "%s/%s.dist", get_tc_lib(), type);
+	snprintf(name, sizeof(name), "%s/%s.dist", get_tc_datadir(), type);
 	if ((f = fopen(name, "r")) == NULL) {
 		fprintf(stderr, "No distribution data for %s (%s: %s)\n",
 			type, name, strerror(errno));
diff -ruN iproute2-4.20.0/tc/q_netem.c.orig iproute2-4.20.0_b/tc/q_netem.c.orig
--- iproute2-4.20.0/tc/q_netem.c.orig	1970-01-01 03:00:00.000000000 +0300
+++ iproute2-4.20.0_b/tc/q_netem.c.orig	2019-01-07 21:24:02.000000000 +0300
@@ -0,0 +1,789 @@
+/*
+ * q_netem.c		NETEM.
+ *
+ *		This program is free software; you can redistribute it and/or
+ *		modify it under the terms of the GNU General Public License
+ *		as published by the Free Software Foundation; either version
+ *		2 of the License, or (at your option) any later version.
+ *
+ * Authors:	Stephen Hemminger <shemminger@linux-foundation.org>
+ *
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <math.h>
+#include <ctype.h>
+#include <unistd.h>
+#include <fcntl.h>
+#include <stdint.h>
+#include <sys/socket.h>
+#include <netinet/in.h>
+#include <arpa/inet.h>
+#include <string.h>
+#include <errno.h>
+
+#include "utils.h"
+#include "tc_util.h"
+#include "tc_common.h"
+
+static void explain(void)
+{
+	fprintf(stderr,
+"Usage: ... netem [ limit PACKETS ]\n" \
+"                 [ delay TIME [ JITTER [CORRELATION]]]\n" \
+"                 [ distribution {uniform|normal|pareto|paretonormal} ]\n" \
+"                 [ corrupt PERCENT [CORRELATION]]\n" \
+"                 [ duplicate PERCENT [CORRELATION]]\n" \
+"                 [ loss random PERCENT [CORRELATION]]\n" \
+"                 [ loss state P13 [P31 [P32 [P23 P14]]]\n" \
+"                 [ loss gemodel PERCENT [R [1-H [1-K]]]\n" \
+"                 [ ecn ]\n" \
+"                 [ reorder PRECENT [CORRELATION] [ gap DISTANCE ]]\n" \
+"                 [ rate RATE [PACKETOVERHEAD] [CELLSIZE] [CELLOVERHEAD]]\n" \
+"                 [ slot MIN_DELAY [MAX_DELAY] [packets MAX_PACKETS]" \
+" [bytes MAX_BYTES]]\n" \
+"                 [ slot distribution" \
+" {uniform|normal|pareto|paretonormal|custom} DELAY JITTER" \
+" [packets MAX_PACKETS] [bytes MAX_BYTES]]\n");
+}
+
+static void explain1(const char *arg)
+{
+	fprintf(stderr, "Illegal \"%s\"\n", arg);
+}
+
+/* Upper bound on size of distribution
+ *  really (TCA_BUF_MAX - other headers) / sizeof (__s16)
+ */
+#define MAX_DIST	(16*1024)
+
+/* scaled value used to percent of maximum. */
+static void set_percent(__u32 *percent, double per)
+{
+	*percent = rint(per * UINT32_MAX);
+}
+
+static int get_percent(__u32 *percent, const char *str)
+{
+	double per;
+
+	if (parse_percent(&per, str))
+		return -1;
+
+	set_percent(percent, per);
+	return 0;
+}
+
+static void print_percent(char *buf, int len, __u32 per)
+{
+	snprintf(buf, len, "%g%%", (100. * per) / UINT32_MAX);
+}
+
+static char *sprint_percent(__u32 per, char *buf)
+{
+	print_percent(buf, SPRINT_BSIZE-1, per);
+	return buf;
+}
+
+/*
+ * Simplistic file parser for distrbution data.
+ * Format is:
+ *	# comment line(s)
+ *	data0 data1 ...
+ */
+static int get_distribution(const char *type, __s16 *data, int maxdata)
+{
+	FILE *f;
+	int n;
+	long x;
+	size_t len;
+	char *line = NULL;
+	char name[128];
+
+	snprintf(name, sizeof(name), "%s/%s.dist", get_tc_lib(), type);
+	if ((f = fopen(name, "r")) == NULL) {
+		fprintf(stderr, "No distribution data for %s (%s: %s)\n",
+			type, name, strerror(errno));
+		return -1;
+	}
+
+	n = 0;
+	while (getline(&line, &len, f) != -1) {
+		char *p, *endp;
+
+		if (*line == '\n' || *line == '#')
+			continue;
+
+		for (p = line; ; p = endp) {
+			x = strtol(p, &endp, 0);
+			if (endp == p)
+				break;
+
+			if (n >= maxdata) {
+				fprintf(stderr, "%s: too much data\n",
+					name);
+				n = -1;
+				goto error;
+			}
+			data[n++] = x;
+		}
+	}
+ error:
+	free(line);
+	fclose(f);
+	return n;
+}
+
+#define NEXT_IS_NUMBER() (NEXT_ARG_OK() && isdigit(argv[1][0]))
+#define NEXT_IS_SIGNED_NUMBER() \
+	(NEXT_ARG_OK() && (isdigit(argv[1][0]) || argv[1][0] == '-'))
+
+/* Adjust for the fact that psched_ticks aren't always usecs
+   (based on kernel PSCHED_CLOCK configuration */
+static int get_ticks(__u32 *ticks, const char *str)
+{
+	unsigned int t;
+
+	if (get_time(&t, str))
+		return -1;
+
+	if (tc_core_time2big(t)) {
+		fprintf(stderr, "Illegal %u time (too large)\n", t);
+		return -1;
+	}
+
+	*ticks = tc_core_time2tick(t);
+	return 0;
+}
+
+static int netem_parse_opt(struct qdisc_util *qu, int argc, char **argv,
+			   struct nlmsghdr *n, const char *dev)
+{
+	int dist_size = 0;
+	int slot_dist_size = 0;
+	struct rtattr *tail;
+	struct tc_netem_qopt opt = { .limit = 1000 };
+	struct tc_netem_corr cor = {};
+	struct tc_netem_reorder reorder = {};
+	struct tc_netem_corrupt corrupt = {};
+	struct tc_netem_gimodel gimodel;
+	struct tc_netem_gemodel gemodel;
+	struct tc_netem_rate rate = {};
+	struct tc_netem_slot slot = {};
+	__s16 *dist_data = NULL;
+	__s16 *slot_dist_data = NULL;
+	__u16 loss_type = NETEM_LOSS_UNSPEC;
+	int present[__TCA_NETEM_MAX] = {};
+	__u64 rate64 = 0;
+
+	for ( ; argc > 0; --argc, ++argv) {
+		if (matches(*argv, "limit") == 0) {
+			NEXT_ARG();
+			if (get_size(&opt.limit, *argv)) {
+				explain1("limit");
+				return -1;
+			}
+		} else if (matches(*argv, "latency") == 0 ||
+			   matches(*argv, "delay") == 0) {
+			NEXT_ARG();
+			if (get_ticks(&opt.latency, *argv)) {
+				explain1("latency");
+				return -1;
+			}
+
+			if (NEXT_IS_NUMBER()) {
+				NEXT_ARG();
+				if (get_ticks(&opt.jitter, *argv)) {
+					explain1("latency");
+					return -1;
+				}
+
+				if (NEXT_IS_NUMBER()) {
+					NEXT_ARG();
+					++present[TCA_NETEM_CORR];
+					if (get_percent(&cor.delay_corr, *argv)) {
+						explain1("latency");
+						return -1;
+					}
+				}
+			}
+		} else if (matches(*argv, "loss") == 0 ||
+			   matches(*argv, "drop") == 0) {
+			if (opt.loss > 0 || loss_type != NETEM_LOSS_UNSPEC) {
+				explain1("duplicate loss argument\n");
+				return -1;
+			}
+
+			NEXT_ARG();
+			/* Old (deprecated) random loss model syntax */
+			if (isdigit(argv[0][0]))
+				goto random_loss_model;
+
+			if (!strcmp(*argv, "random")) {
+				NEXT_ARG();
+			random_loss_model:
+				if (get_percent(&opt.loss, *argv)) {
+					explain1("loss percent");
+					return -1;
+				}
+				if (NEXT_IS_NUMBER()) {
+					NEXT_ARG();
+					++present[TCA_NETEM_CORR];
+					if (get_percent(&cor.loss_corr, *argv)) {
+						explain1("loss correllation");
+						return -1;
+					}
+				}
+			} else if (!strcmp(*argv, "state")) {
+				double p13;
+
+				NEXT_ARG();
+				if (parse_percent(&p13, *argv)) {
+					explain1("loss p13");
+					return -1;
+				}
+
+				/* set defaults */
+				set_percent(&gimodel.p13, p13);
+				set_percent(&gimodel.p31, 1. - p13);
+				set_percent(&gimodel.p32, 0);
+				set_percent(&gimodel.p23, 1.);
+				set_percent(&gimodel.p14, 0);
+				loss_type = NETEM_LOSS_GI;
+
+				if (!NEXT_IS_NUMBER())
+					continue;
+				NEXT_ARG();
+				if (get_percent(&gimodel.p31, *argv)) {
+					explain1("loss p31");
+					return -1;
+				}
+
+				if (!NEXT_IS_NUMBER())
+					continue;
+				NEXT_ARG();
+				if (get_percent(&gimodel.p32, *argv)) {
+					explain1("loss p32");
+					return -1;
+				}
+
+				if (!NEXT_IS_NUMBER())
+					continue;
+				NEXT_ARG();
+				if (get_percent(&gimodel.p23, *argv)) {
+					explain1("loss p23");
+					return -1;
+				}
+				if (!NEXT_IS_NUMBER())
+					continue;
+				NEXT_ARG();
+				if (get_percent(&gimodel.p14, *argv)) {
+					explain1("loss p14");
+					return -1;
+				}
+
+			} else if (!strcmp(*argv, "gemodel")) {
+				NEXT_ARG();
+				if (get_percent(&gemodel.p, *argv)) {
+					explain1("loss gemodel p");
+					return -1;
+				}
+
+				/* set defaults */
+				set_percent(&gemodel.r, 1.);
+				set_percent(&gemodel.h, 0);
+				set_percent(&gemodel.k1, 0);
+				loss_type = NETEM_LOSS_GE;
+
+				if (!NEXT_IS_NUMBER())
+					continue;
+				NEXT_ARG();
+				if (get_percent(&gemodel.r, *argv)) {
+					explain1("loss gemodel r");
+					return -1;
+				}
+
+				if (!NEXT_IS_NUMBER())
+					continue;
+				NEXT_ARG();
+				if (get_percent(&gemodel.h, *argv)) {
+					explain1("loss gemodel h");
+					return -1;
+				}
+				/* netem option is "1-h" but kernel
+				 * expects "h".
+				 */
+				gemodel.h = UINT32_MAX - gemodel.h;
+
+				if (!NEXT_IS_NUMBER())
+					continue;
+				NEXT_ARG();
+				if (get_percent(&gemodel.k1, *argv)) {
+					explain1("loss gemodel k");
+					return -1;
+				}
+			} else {
+				fprintf(stderr, "Unknown loss parameter: %s\n",
+					*argv);
+				return -1;
+			}
+		} else if (matches(*argv, "ecn") == 0) {
+			present[TCA_NETEM_ECN] = 1;
+		} else if (matches(*argv, "reorder") == 0) {
+			NEXT_ARG();
+			present[TCA_NETEM_REORDER] = 1;
+			if (get_percent(&reorder.probability, *argv)) {
+				explain1("reorder");
+				return -1;
+			}
+			if (NEXT_IS_NUMBER()) {
+				NEXT_ARG();
+				++present[TCA_NETEM_CORR];
+				if (get_percent(&reorder.correlation, *argv)) {
+					explain1("reorder");
+					return -1;
+				}
+			}
+		} else if (matches(*argv, "corrupt") == 0) {
+			NEXT_ARG();
+			present[TCA_NETEM_CORRUPT] = 1;
+			if (get_percent(&corrupt.probability, *argv)) {
+				explain1("corrupt");
+				return -1;
+			}
+			if (NEXT_IS_NUMBER()) {
+				NEXT_ARG();
+				++present[TCA_NETEM_CORR];
+				if (get_percent(&corrupt.correlation, *argv)) {
+					explain1("corrupt");
+					return -1;
+				}
+			}
+		} else if (matches(*argv, "gap") == 0) {
+			NEXT_ARG();
+			if (get_u32(&opt.gap, *argv, 0)) {
+				explain1("gap");
+				return -1;
+			}
+		} else if (matches(*argv, "duplicate") == 0) {
+			NEXT_ARG();
+			if (get_percent(&opt.duplicate, *argv)) {
+				explain1("duplicate");
+				return -1;
+			}
+			if (NEXT_IS_NUMBER()) {
+				NEXT_ARG();
+				if (get_percent(&cor.dup_corr, *argv)) {
+					explain1("duplicate");
+					return -1;
+				}
+			}
+		} else if (matches(*argv, "distribution") == 0) {
+			NEXT_ARG();
+			dist_data = calloc(sizeof(dist_data[0]), MAX_DIST);
+			dist_size = get_distribution(*argv, dist_data, MAX_DIST);
+			if (dist_size <= 0) {
+				free(dist_data);
+				return -1;
+			}
+		} else if (matches(*argv, "rate") == 0) {
+			++present[TCA_NETEM_RATE];
+			NEXT_ARG();
+			if (strchr(*argv, '%')) {
+				if (get_percent_rate64(&rate64, *argv, dev)) {
+					explain1("rate");
+					return -1;
+				}
+			} else if (get_rate64(&rate64, *argv)) {
+				explain1("rate");
+				return -1;
+			}
+			if (NEXT_IS_SIGNED_NUMBER()) {
+				NEXT_ARG();
+				if (get_s32(&rate.packet_overhead, *argv, 0)) {
+					explain1("rate");
+					return -1;
+				}
+			}
+			if (NEXT_IS_NUMBER()) {
+				NEXT_ARG();
+				if (get_u32(&rate.cell_size, *argv, 0)) {
+					explain1("rate");
+					return -1;
+				}
+			}
+			if (NEXT_IS_SIGNED_NUMBER()) {
+				NEXT_ARG();
+				if (get_s32(&rate.cell_overhead, *argv, 0)) {
+					explain1("rate");
+					return -1;
+				}
+			}
+		} else if (matches(*argv, "slot") == 0) {
+			if (NEXT_IS_NUMBER()) {
+				NEXT_ARG();
+				present[TCA_NETEM_SLOT] = 1;
+				if (get_time64(&slot.min_delay, *argv)) {
+					explain1("slot min_delay");
+					return -1;
+				}
+				if (NEXT_IS_NUMBER()) {
+					NEXT_ARG();
+					if (get_time64(&slot.max_delay, *argv) ||
+					    slot.max_delay < slot.min_delay) {
+						explain1("slot max_delay");
+						return -1;
+					}
+				} else {
+					slot.max_delay = slot.min_delay;
+				}
+			} else {
+				NEXT_ARG();
+				if (strcmp(*argv, "distribution") == 0) {
+					present[TCA_NETEM_SLOT] = 1;
+					NEXT_ARG();
+					slot_dist_data = calloc(sizeof(slot_dist_data[0]), MAX_DIST);
+					if (!slot_dist_data)
+						return -1;
+					slot_dist_size = get_distribution(*argv, slot_dist_data, MAX_DIST);
+					if (slot_dist_size <= 0) {
+						free(slot_dist_data);
+						return -1;
+					}
+					NEXT_ARG();
+					if (get_time64(&slot.dist_delay, *argv)) {
+						explain1("slot delay");
+						return -1;
+					}
+					NEXT_ARG();
+					if (get_time64(&slot.dist_jitter, *argv)) {
+						explain1("slot jitter");
+						return -1;
+					}
+					if (slot.dist_jitter <= 0) {
+						fprintf(stderr, "Non-positive jitter\n");
+						return -1;
+					}
+				} else {
+					fprintf(stderr, "Unknown slot parameter: %s\n",
+						*argv);
+					return -1;
+				}
+			}
+			if (NEXT_ARG_OK() &&
+			    matches(*(argv+1), "packets") == 0) {
+				NEXT_ARG();
+				if (!NEXT_ARG_OK() ||
+				    get_s32(&slot.max_packets, *(argv+1), 0)) {
+					explain1("slot packets");
+					return -1;
+				}
+				NEXT_ARG();
+			}
+			if (NEXT_ARG_OK() &&
+			    matches(*(argv+1), "bytes") == 0) {
+				unsigned int max_bytes;
+				NEXT_ARG();
+				if (!NEXT_ARG_OK() ||
+				    get_size(&max_bytes, *(argv+1))) {
+					explain1("slot bytes");
+					return -1;
+				}
+				slot.max_bytes = (int) max_bytes;
+				NEXT_ARG();
+			}
+		} else if (strcmp(*argv, "help") == 0) {
+			explain();
+			return -1;
+		} else {
+			fprintf(stderr, "What is \"%s\"?\n", *argv);
+			explain();
+			return -1;
+		}
+	}
+
+	tail = NLMSG_TAIL(n);
+
+	if (reorder.probability) {
+		if (opt.latency == 0) {
+			fprintf(stderr, "reordering not possible without specifying some delay\n");
+			explain();
+			return -1;
+		}
+		if (opt.gap == 0)
+			opt.gap = 1;
+	} else if (opt.gap > 0) {
+		fprintf(stderr, "gap specified without reorder probability\n");
+		explain();
+		return -1;
+	}
+
+	if (present[TCA_NETEM_ECN]) {
+		if (opt.loss <= 0 && loss_type == NETEM_LOSS_UNSPEC) {
+			fprintf(stderr, "ecn requested without loss model\n");
+			explain();
+			return -1;
+		}
+	}
+
+	if (dist_data && (opt.latency == 0 || opt.jitter == 0)) {
+		fprintf(stderr, "distribution specified but no latency and jitter values\n");
+		explain();
+		return -1;
+	}
+
+	if (addattr_l(n, 1024, TCA_OPTIONS, &opt, sizeof(opt)) < 0)
+		return -1;
+
+	if (present[TCA_NETEM_CORR] &&
+	    addattr_l(n, 1024, TCA_NETEM_CORR, &cor, sizeof(cor)) < 0)
+		return -1;
+
+	if (present[TCA_NETEM_REORDER] &&
+	    addattr_l(n, 1024, TCA_NETEM_REORDER, &reorder, sizeof(reorder)) < 0)
+		return -1;
+
+	if (present[TCA_NETEM_ECN] &&
+	    addattr_l(n, 1024, TCA_NETEM_ECN, &present[TCA_NETEM_ECN],
+		      sizeof(present[TCA_NETEM_ECN])) < 0)
+		return -1;
+
+	if (present[TCA_NETEM_CORRUPT] &&
+	    addattr_l(n, 1024, TCA_NETEM_CORRUPT, &corrupt, sizeof(corrupt)) < 0)
+		return -1;
+
+	if (present[TCA_NETEM_SLOT] &&
+	    addattr_l(n, 1024, TCA_NETEM_SLOT, &slot, sizeof(slot)) < 0)
+		return -1;
+
+	if (loss_type != NETEM_LOSS_UNSPEC) {
+		struct rtattr *start;
+
+		start = addattr_nest(n, 1024, TCA_NETEM_LOSS | NLA_F_NESTED);
+		if (loss_type == NETEM_LOSS_GI) {
+			if (addattr_l(n, 1024, NETEM_LOSS_GI,
+				      &gimodel, sizeof(gimodel)) < 0)
+				return -1;
+		} else if (loss_type == NETEM_LOSS_GE) {
+			if (addattr_l(n, 1024, NETEM_LOSS_GE,
+				      &gemodel, sizeof(gemodel)) < 0)
+				return -1;
+		} else {
+			fprintf(stderr, "loss in the weeds!\n");
+			return -1;
+		}
+
+		addattr_nest_end(n, start);
+	}
+
+	if (present[TCA_NETEM_RATE]) {
+		if (rate64 >= (1ULL << 32)) {
+			if (addattr_l(n, 1024,
+				      TCA_NETEM_RATE64, &rate64, sizeof(rate64)) < 0)
+				return -1;
+			rate.rate = ~0U;
+		} else {
+			rate.rate = rate64;
+		}
+		if (addattr_l(n, 1024, TCA_NETEM_RATE, &rate, sizeof(rate)) < 0)
+			return -1;
+	}
+
+	if (dist_data) {
+		if (addattr_l(n, MAX_DIST * sizeof(dist_data[0]),
+			      TCA_NETEM_DELAY_DIST,
+			      dist_data, dist_size * sizeof(dist_data[0])) < 0)
+			return -1;
+		free(dist_data);
+	}
+
+	if (slot_dist_data) {
+		if (addattr_l(n, MAX_DIST * sizeof(slot_dist_data[0]),
+			      TCA_NETEM_SLOT_DIST,
+			      slot_dist_data, slot_dist_size * sizeof(slot_dist_data[0])) < 0)
+			return -1;
+		free(slot_dist_data);
+	}
+	tail->rta_len = (void *) NLMSG_TAIL(n) - (void *) tail;
+	return 0;
+}
+
+static int netem_print_opt(struct qdisc_util *qu, FILE *f, struct rtattr *opt)
+{
+	const struct tc_netem_corr *cor = NULL;
+	const struct tc_netem_reorder *reorder = NULL;
+	const struct tc_netem_corrupt *corrupt = NULL;
+	const struct tc_netem_gimodel *gimodel = NULL;
+	const struct tc_netem_gemodel *gemodel = NULL;
+	int *ecn = NULL;
+	struct tc_netem_qopt qopt;
+	const struct tc_netem_rate *rate = NULL;
+	const struct tc_netem_slot *slot = NULL;
+	int len;
+	__u64 rate64 = 0;
+
+	SPRINT_BUF(b1);
+
+	if (opt == NULL)
+		return 0;
+
+	len = RTA_PAYLOAD(opt) - sizeof(qopt);
+	if (len < 0) {
+		fprintf(stderr, "options size error\n");
+		return -1;
+	}
+	memcpy(&qopt, RTA_DATA(opt), sizeof(qopt));
+
+	if (len > 0) {
+		struct rtattr *tb[TCA_NETEM_MAX+1];
+
+		parse_rtattr(tb, TCA_NETEM_MAX, RTA_DATA(opt) + sizeof(qopt),
+			     len);
+
+		if (tb[TCA_NETEM_CORR]) {
+			if (RTA_PAYLOAD(tb[TCA_NETEM_CORR]) < sizeof(*cor))
+				return -1;
+			cor = RTA_DATA(tb[TCA_NETEM_CORR]);
+		}
+		if (tb[TCA_NETEM_REORDER]) {
+			if (RTA_PAYLOAD(tb[TCA_NETEM_REORDER]) < sizeof(*reorder))
+				return -1;
+			reorder = RTA_DATA(tb[TCA_NETEM_REORDER]);
+		}
+		if (tb[TCA_NETEM_CORRUPT]) {
+			if (RTA_PAYLOAD(tb[TCA_NETEM_CORRUPT]) < sizeof(*corrupt))
+				return -1;
+			corrupt = RTA_DATA(tb[TCA_NETEM_CORRUPT]);
+		}
+		if (tb[TCA_NETEM_LOSS]) {
+			struct rtattr *lb[NETEM_LOSS_MAX + 1];
+
+			parse_rtattr_nested(lb, NETEM_LOSS_MAX, tb[TCA_NETEM_LOSS]);
+			if (lb[NETEM_LOSS_GI])
+				gimodel = RTA_DATA(lb[NETEM_LOSS_GI]);
+			if (lb[NETEM_LOSS_GE])
+				gemodel = RTA_DATA(lb[NETEM_LOSS_GE]);
+		}
+		if (tb[TCA_NETEM_RATE]) {
+			if (RTA_PAYLOAD(tb[TCA_NETEM_RATE]) < sizeof(*rate))
+				return -1;
+			rate = RTA_DATA(tb[TCA_NETEM_RATE]);
+		}
+		if (tb[TCA_NETEM_ECN]) {
+			if (RTA_PAYLOAD(tb[TCA_NETEM_ECN]) < sizeof(*ecn))
+				return -1;
+			ecn = RTA_DATA(tb[TCA_NETEM_ECN]);
+		}
+		if (tb[TCA_NETEM_RATE64]) {
+			if (RTA_PAYLOAD(tb[TCA_NETEM_RATE64]) < sizeof(rate64))
+				return -1;
+			rate64 = rta_getattr_u64(tb[TCA_NETEM_RATE64]);
+		}
+		if (tb[TCA_NETEM_SLOT]) {
+			if (RTA_PAYLOAD(tb[TCA_NETEM_SLOT]) < sizeof(*slot))
+				return -1;
+			slot = RTA_DATA(tb[TCA_NETEM_SLOT]);
+		}
+	}
+
+	fprintf(f, "limit %d", qopt.limit);
+
+	if (qopt.latency) {
+		fprintf(f, " delay %s", sprint_ticks(qopt.latency, b1));
+
+		if (qopt.jitter) {
+			fprintf(f, "  %s", sprint_ticks(qopt.jitter, b1));
+			if (cor && cor->delay_corr)
+				fprintf(f, " %s", sprint_percent(cor->delay_corr, b1));
+		}
+	}
+
+	if (qopt.loss) {
+		fprintf(f, " loss %s", sprint_percent(qopt.loss, b1));
+		if (cor && cor->loss_corr)
+			fprintf(f, " %s", sprint_percent(cor->loss_corr, b1));
+	}
+
+	if (gimodel) {
+		fprintf(f, " loss state p13 %s", sprint_percent(gimodel->p13, b1));
+		fprintf(f, " p31 %s", sprint_percent(gimodel->p31, b1));
+		fprintf(f, " p32 %s", sprint_percent(gimodel->p32, b1));
+		fprintf(f, " p23 %s", sprint_percent(gimodel->p23, b1));
+		fprintf(f, " p14 %s", sprint_percent(gimodel->p14, b1));
+	}
+
+	if (gemodel) {
+		fprintf(f, " loss gemodel p %s",
+			sprint_percent(gemodel->p, b1));
+		fprintf(f, " r %s", sprint_percent(gemodel->r, b1));
+		fprintf(f, " 1-h %s", sprint_percent(UINT32_MAX -
+						     gemodel->h, b1));
+		fprintf(f, " 1-k %s", sprint_percent(gemodel->k1, b1));
+	}
+
+	if (qopt.duplicate) {
+		fprintf(f, " duplicate %s",
+			sprint_percent(qopt.duplicate, b1));
+		if (cor && cor->dup_corr)
+			fprintf(f, " %s", sprint_percent(cor->dup_corr, b1));
+	}
+
+	if (reorder && reorder->probability) {
+		fprintf(f, " reorder %s",
+			sprint_percent(reorder->probability, b1));
+		if (reorder->correlation)
+			fprintf(f, " %s",
+				sprint_percent(reorder->correlation, b1));
+	}
+
+	if (corrupt && corrupt->probability) {
+		fprintf(f, " corrupt %s",
+			sprint_percent(corrupt->probability, b1));
+		if (corrupt->correlation)
+			fprintf(f, " %s",
+				sprint_percent(corrupt->correlation, b1));
+	}
+
+	if (rate && rate->rate) {
+		if (rate64)
+			fprintf(f, " rate %s", sprint_rate(rate64, b1));
+		else
+			fprintf(f, " rate %s", sprint_rate(rate->rate, b1));
+		if (rate->packet_overhead)
+			fprintf(f, " packetoverhead %d", rate->packet_overhead);
+		if (rate->cell_size)
+			fprintf(f, " cellsize %u", rate->cell_size);
+		if (rate->cell_overhead)
+			fprintf(f, " celloverhead %d", rate->cell_overhead);
+	}
+
+	if (slot) {
+		if (slot->dist_jitter > 0) {
+		    fprintf(f, " slot distribution %s", sprint_time64(slot->dist_delay, b1));
+		    fprintf(f, " %s", sprint_time64(slot->dist_jitter, b1));
+		} else {
+		    fprintf(f, " slot %s", sprint_time64(slot->min_delay, b1));
+		    fprintf(f, " %s", sprint_time64(slot->max_delay, b1));
+		}
+		if (slot->max_packets)
+			fprintf(f, " packets %d", slot->max_packets);
+		if (slot->max_bytes)
+			fprintf(f, " bytes %d", slot->max_bytes);
+	}
+
+	if (ecn)
+		fprintf(f, " ecn ");
+
+	if (qopt.gap)
+		fprintf(f, " gap %lu", (unsigned long)qopt.gap);
+
+
+	return 0;
+}
+
+struct qdisc_util netem_qdisc_util = {
+	.id		= "netem",
+	.parse_qopt	= netem_parse_opt,
+	.print_qopt	= netem_print_opt,
+};
diff -ruN iproute2-4.20.0/tc/tc_util.c iproute2-4.20.0_b/tc/tc_util.c
--- iproute2-4.20.0/tc/tc_util.c	2019-01-07 21:24:02.000000000 +0300
+++ iproute2-4.20.0_b/tc/tc_util.c	2019-03-14 15:27:08.844797498 +0300
@@ -31,6 +31,10 @@
 #define LIBDIR "/usr/lib"
 #endif
 
+#ifndef DATADIR
+#define DATADIR "/usr/share"
+#endif
+
 static struct db_names *cls_names;
 
 #define NAMES_DB "/etc/iproute2/tc_cls"
@@ -72,6 +76,17 @@
 	return lib_dir;
 }
 
+const char *get_tc_datadir(void)
+{
+	const char *data_dir;
+
+	data_dir = getenv("TC_DATA_DIR");
+	if (!data_dir)
+		data_dir = DATADIR "/tc/";
+
+	return data_dir;
+}
+
 int get_qdisc_handle(__u32 *h, const char *str)
 {
 	__u32 maj;
diff -ruN iproute2-4.20.0/tc/tc_util.c.orig iproute2-4.20.0_b/tc/tc_util.c.orig
--- iproute2-4.20.0/tc/tc_util.c.orig	1970-01-01 03:00:00.000000000 +0300
+++ iproute2-4.20.0_b/tc/tc_util.c.orig	2019-01-07 21:24:02.000000000 +0300
@@ -0,0 +1,897 @@
+/*
+ * tc_util.c		Misc TC utility functions.
+ *
+ *		This program is free software; you can redistribute it and/or
+ *		modify it under the terms of the GNU General Public License
+ *		as published by the Free Software Foundation; either version
+ *		2 of the License, or (at your option) any later version.
+ *
+ * Authors:	Alexey Kuznetsov, <kuznet@ms2.inr.ac.ru>
+ *
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <fcntl.h>
+#include <sys/socket.h>
+#include <sys/param.h>
+#include <netinet/in.h>
+#include <arpa/inet.h>
+#include <string.h>
+#include <math.h>
+#include <errno.h>
+
+#include "utils.h"
+#include "names.h"
+#include "tc_util.h"
+#include "tc_common.h"
+
+#ifndef LIBDIR
+#define LIBDIR "/usr/lib"
+#endif
+
+static struct db_names *cls_names;
+
+#define NAMES_DB "/etc/iproute2/tc_cls"
+
+int cls_names_init(char *path)
+{
+	int ret;
+
+	cls_names = db_names_alloc();
+	if (!cls_names)
+		return -1;
+
+	ret = db_names_load(cls_names, path ?: NAMES_DB);
+	if (ret == -ENOENT && path) {
+		fprintf(stderr, "Can't open class names file: %s\n", path);
+		return -1;
+	}
+	if (ret) {
+		db_names_free(cls_names);
+		cls_names = NULL;
+	}
+
+	return 0;
+}
+
+void cls_names_uninit(void)
+{
+	db_names_free(cls_names);
+}
+
+const char *get_tc_lib(void)
+{
+	const char *lib_dir;
+
+	lib_dir = getenv("TC_LIB_DIR");
+	if (!lib_dir)
+		lib_dir = LIBDIR "/tc/";
+
+	return lib_dir;
+}
+
+int get_qdisc_handle(__u32 *h, const char *str)
+{
+	__u32 maj;
+	char *p;
+
+	maj = TC_H_UNSPEC;
+	if (strcmp(str, "none") == 0)
+		goto ok;
+	maj = strtoul(str, &p, 16);
+	if (p == str || maj >= (1 << 16))
+		return -1;
+	maj <<= 16;
+	if (*p != ':' && *p != 0)
+		return -1;
+ok:
+	*h = maj;
+	return 0;
+}
+
+int get_tc_classid(__u32 *h, const char *str)
+{
+	__u32 maj, min;
+	char *p;
+
+	maj = TC_H_ROOT;
+	if (strcmp(str, "root") == 0)
+		goto ok;
+	maj = TC_H_UNSPEC;
+	if (strcmp(str, "none") == 0)
+		goto ok;
+	maj = strtoul(str, &p, 16);
+	if (p == str) {
+		maj = 0;
+		if (*p != ':')
+			return -1;
+	}
+	if (*p == ':') {
+		if (maj >= (1<<16))
+			return -1;
+		maj <<= 16;
+		str = p+1;
+		min = strtoul(str, &p, 16);
+		if (*p != 0)
+			return -1;
+		if (min >= (1<<16))
+			return -1;
+		maj |= min;
+	} else if (*p != 0)
+		return -1;
+
+ok:
+	*h = maj;
+	return 0;
+}
+
+int print_tc_classid(char *buf, int blen, __u32 h)
+{
+	SPRINT_BUF(handle) = {};
+	int hlen = SPRINT_BSIZE - 1;
+
+	if (h == TC_H_ROOT)
+		sprintf(handle, "root");
+	else if (h == TC_H_UNSPEC)
+		snprintf(handle, hlen, "none");
+	else if (TC_H_MAJ(h) == 0)
+		snprintf(handle, hlen, ":%x", TC_H_MIN(h));
+	else if (TC_H_MIN(h) == 0)
+		snprintf(handle, hlen, "%x:", TC_H_MAJ(h) >> 16);
+	else
+		snprintf(handle, hlen, "%x:%x", TC_H_MAJ(h) >> 16, TC_H_MIN(h));
+
+	if (use_names) {
+		char clname[IDNAME_MAX] = {};
+
+		if (id_to_name(cls_names, h, clname))
+			snprintf(buf, blen, "%s#%s", clname, handle);
+		else
+			snprintf(buf, blen, "%s", handle);
+	} else {
+		snprintf(buf, blen, "%s", handle);
+	}
+
+	return 0;
+}
+
+char *sprint_tc_classid(__u32 h, char *buf)
+{
+	if (print_tc_classid(buf, SPRINT_BSIZE-1, h))
+		strcpy(buf, "???");
+	return buf;
+}
+
+/* See http://physics.nist.gov/cuu/Units/binary.html */
+static const struct rate_suffix {
+	const char *name;
+	double scale;
+} suffixes[] = {
+	{ "bit",	1. },
+	{ "Kibit",	1024. },
+	{ "kbit",	1000. },
+	{ "mibit",	1024.*1024. },
+	{ "mbit",	1000000. },
+	{ "gibit",	1024.*1024.*1024. },
+	{ "gbit",	1000000000. },
+	{ "tibit",	1024.*1024.*1024.*1024. },
+	{ "tbit",	1000000000000. },
+	{ "Bps",	8. },
+	{ "KiBps",	8.*1024. },
+	{ "KBps",	8000. },
+	{ "MiBps",	8.*1024*1024. },
+	{ "MBps",	8000000. },
+	{ "GiBps",	8.*1024.*1024.*1024. },
+	{ "GBps",	8000000000. },
+	{ "TiBps",	8.*1024.*1024.*1024.*1024. },
+	{ "TBps",	8000000000000. },
+	{ NULL }
+};
+
+static int parse_percent_rate(char *rate, const char *str, const char *dev)
+{
+	long dev_mbit;
+	int ret;
+	double perc, rate_mbit;
+	char *str_perc;
+
+	if (!dev[0]) {
+		fprintf(stderr, "No device specified; specify device to rate limit by percentage\n");
+		return -1;
+	}
+
+	if (read_prop(dev, "speed", &dev_mbit))
+		return -1;
+
+	ret = sscanf(str, "%m[0-9.%]", &str_perc);
+	if (ret != 1)
+		goto malf;
+
+	if (parse_percent(&perc, str_perc))
+		goto malf;
+
+	free(str_perc);
+
+	if (perc > 1.0 || perc < 0.0) {
+		fprintf(stderr, "Invalid rate specified; should be between [0,100]%% but is %s\n", str);
+		return -1;
+	}
+
+	rate_mbit = perc * dev_mbit;
+
+	ret = snprintf(rate, 20, "%lf", rate_mbit);
+	if (ret <= 0 || ret >= 20) {
+		fprintf(stderr, "Unable to parse calculated rate\n");
+		return -1;
+	}
+
+	return 0;
+
+malf:
+	fprintf(stderr, "Specified rate value could not be read or is malformed\n");
+	return -1;
+}
+
+int get_percent_rate(unsigned int *rate, const char *str, const char *dev)
+{
+	char r_str[20];
+
+	if (parse_percent_rate(r_str, str, dev))
+		return -1;
+
+	return get_rate(rate, r_str);
+}
+
+int get_percent_rate64(__u64 *rate, const char *str, const char *dev)
+{
+	char r_str[20];
+
+	if (parse_percent_rate(r_str, str, dev))
+		return -1;
+
+	return get_rate64(rate, r_str);
+}
+
+int get_rate(unsigned int *rate, const char *str)
+{
+	char *p;
+	double bps = strtod(str, &p);
+	const struct rate_suffix *s;
+
+	if (p == str)
+		return -1;
+
+	for (s = suffixes; s->name; ++s) {
+		if (strcasecmp(s->name, p) == 0) {
+			bps *= s->scale;
+			p += strlen(p);
+			break;
+		}
+	}
+
+	if (*p)
+		return -1; /* unknown suffix */
+
+	bps /= 8; /* -> bytes per second */
+	*rate = bps;
+	/* detect if an overflow happened */
+	if (*rate != floor(bps))
+		return -1;
+	return 0;
+}
+
+int get_rate64(__u64 *rate, const char *str)
+{
+	char *p;
+	double bps = strtod(str, &p);
+	const struct rate_suffix *s;
+
+	if (p == str)
+		return -1;
+
+	for (s = suffixes; s->name; ++s) {
+		if (strcasecmp(s->name, p) == 0) {
+			bps *= s->scale;
+			p += strlen(p);
+			break;
+		}
+	}
+
+	if (*p)
+		return -1; /* unknown suffix */
+
+	bps /= 8; /* -> bytes per second */
+	*rate = bps;
+	return 0;
+}
+
+void print_rate(char *buf, int len, __u64 rate)
+{
+	extern int use_iec;
+	unsigned long kilo = use_iec ? 1024 : 1000;
+	const char *str = use_iec ? "i" : "";
+	static char *units[5] = {"", "K", "M", "G", "T"};
+	int i;
+
+	rate <<= 3; /* bytes/sec -> bits/sec */
+
+	for (i = 0; i < ARRAY_SIZE(units) - 1; i++)  {
+		if (rate < kilo)
+			break;
+		if (((rate % kilo) != 0) && rate < 1000*kilo)
+			break;
+		rate /= kilo;
+	}
+
+	snprintf(buf, len, "%.0f%s%sbit", (double)rate, units[i], str);
+}
+
+char *sprint_rate(__u64 rate, char *buf)
+{
+	print_rate(buf, SPRINT_BSIZE-1, rate);
+	return buf;
+}
+
+char *sprint_ticks(__u32 ticks, char *buf)
+{
+	return sprint_time(tc_core_tick2time(ticks), buf);
+}
+
+int get_size(unsigned int *size, const char *str)
+{
+	double sz;
+	char *p;
+
+	sz = strtod(str, &p);
+	if (p == str)
+		return -1;
+
+	if (*p) {
+		if (strcasecmp(p, "kb") == 0 || strcasecmp(p, "k") == 0)
+			sz *= 1024;
+		else if (strcasecmp(p, "gb") == 0 || strcasecmp(p, "g") == 0)
+			sz *= 1024*1024*1024;
+		else if (strcasecmp(p, "gbit") == 0)
+			sz *= 1024*1024*1024/8;
+		else if (strcasecmp(p, "mb") == 0 || strcasecmp(p, "m") == 0)
+			sz *= 1024*1024;
+		else if (strcasecmp(p, "mbit") == 0)
+			sz *= 1024*1024/8;
+		else if (strcasecmp(p, "kbit") == 0)
+			sz *= 1024/8;
+		else if (strcasecmp(p, "b") != 0)
+			return -1;
+	}
+
+	*size = sz;
+	return 0;
+}
+
+int get_size_and_cell(unsigned int *size, int *cell_log, char *str)
+{
+	char *slash = strchr(str, '/');
+
+	if (slash)
+		*slash = 0;
+
+	if (get_size(size, str))
+		return -1;
+
+	if (slash) {
+		int cell;
+		int i;
+
+		if (get_integer(&cell, slash+1, 0))
+			return -1;
+		*slash = '/';
+
+		for (i = 0; i < 32; i++) {
+			if ((1<<i) == cell) {
+				*cell_log = i;
+				return 0;
+			}
+		}
+		return -1;
+	}
+	return 0;
+}
+
+void print_devname(enum output_type type, int ifindex)
+{
+	const char *ifname = ll_index_to_name(ifindex);
+
+	if (!is_json_context())
+		printf("dev ");
+
+	print_color_string(type, COLOR_IFNAME,
+			   "dev", "%s ", ifname);
+}
+
+static void print_size(char *buf, int len, __u32 sz)
+{
+	double tmp = sz;
+
+	if (sz >= 1024*1024 && fabs(1024*1024*rint(tmp/(1024*1024)) - sz) < 1024)
+		snprintf(buf, len, "%gMb", rint(tmp/(1024*1024)));
+	else if (sz >= 1024 && fabs(1024*rint(tmp/1024) - sz) < 16)
+		snprintf(buf, len, "%gKb", rint(tmp/1024));
+	else
+		snprintf(buf, len, "%ub", sz);
+}
+
+char *sprint_size(__u32 size, char *buf)
+{
+	print_size(buf, SPRINT_BSIZE-1, size);
+	return buf;
+}
+
+static const char *action_n2a(int action)
+{
+	static char buf[64];
+
+	if (TC_ACT_EXT_CMP(action, TC_ACT_GOTO_CHAIN))
+		return "goto";
+	if (TC_ACT_EXT_CMP(action, TC_ACT_JUMP))
+		return "jump";
+	switch (action) {
+	case TC_ACT_UNSPEC:
+		return "continue";
+	case TC_ACT_OK:
+		return "pass";
+	case TC_ACT_SHOT:
+		return "drop";
+	case TC_ACT_RECLASSIFY:
+		return "reclassify";
+	case TC_ACT_PIPE:
+		return "pipe";
+	case TC_ACT_STOLEN:
+		return "stolen";
+	case TC_ACT_TRAP:
+		return "trap";
+	default:
+		snprintf(buf, 64, "%d", action);
+		return buf;
+	}
+}
+
+/* Convert action branch name into numeric format.
+ *
+ * Parameters:
+ * @arg - string to parse
+ * @result - pointer to output variable
+ * @allow_num - whether @arg may be in numeric format already
+ *
+ * In error case, returns -1 and does not touch @result. Otherwise returns 0.
+ */
+int action_a2n(char *arg, int *result, bool allow_num)
+{
+	int n;
+	char dummy;
+	struct {
+		const char *a;
+		int n;
+	} a2n[] = {
+		{"continue", TC_ACT_UNSPEC},
+		{"drop", TC_ACT_SHOT},
+		{"shot", TC_ACT_SHOT},
+		{"pass", TC_ACT_OK},
+		{"ok", TC_ACT_OK},
+		{"reclassify", TC_ACT_RECLASSIFY},
+		{"pipe", TC_ACT_PIPE},
+		{"goto", TC_ACT_GOTO_CHAIN},
+		{"jump", TC_ACT_JUMP},
+		{"trap", TC_ACT_TRAP},
+		{ NULL },
+	}, *iter;
+
+	for (iter = a2n; iter->a; iter++) {
+		if (matches(arg, iter->a) != 0)
+			continue;
+		n = iter->n;
+		goto out_ok;
+	}
+	if (!allow_num || sscanf(arg, "%d%c", &n, &dummy) != 1)
+		return -1;
+
+out_ok:
+	if (result)
+		*result = n;
+	return 0;
+}
+
+static int __parse_action_control(int *argc_p, char ***argv_p, int *result_p,
+				  bool allow_num, bool ignore_a2n_miss)
+{
+	int argc = *argc_p;
+	char **argv = *argv_p;
+	int result;
+
+	if (!argc)
+		return -1;
+	if (action_a2n(*argv, &result, allow_num) == -1) {
+		if (!ignore_a2n_miss)
+			fprintf(stderr, "Bad action type %s\n", *argv);
+		return -1;
+	}
+	if (result == TC_ACT_GOTO_CHAIN) {
+		__u32 chain_index;
+
+		NEXT_ARG();
+		if (matches(*argv, "chain") != 0) {
+			fprintf(stderr, "\"chain index\" expected\n");
+			return -1;
+		}
+		NEXT_ARG();
+		if (get_u32(&chain_index, *argv, 10) ||
+		    chain_index > TC_ACT_EXT_VAL_MASK) {
+			fprintf(stderr, "Illegal \"chain index\"\n");
+			return -1;
+		}
+		result |= chain_index;
+	}
+	if (result == TC_ACT_JUMP) {
+		__u32 jump_cnt = 0;
+
+		NEXT_ARG();
+		if (get_u32(&jump_cnt, *argv, 10) ||
+		    jump_cnt > TC_ACT_EXT_VAL_MASK) {
+			fprintf(stderr, "Invalid \"jump count\" (%s)\n", *argv);
+			return -1;
+		}
+		result |= jump_cnt;
+	}
+	NEXT_ARG_FWD();
+	*argc_p = argc;
+	*argv_p = argv;
+	*result_p = result;
+	return 0;
+}
+
+/* Parse action control including possible options.
+ *
+ * Parameters:
+ * @argc_p - pointer to argc to parse
+ * @argv_p - pointer to argv to parse
+ * @result_p - pointer to output variable
+ * @allow_num - whether action may be in numeric format already
+ *
+ * In error case, returns -1 and does not touch @result_1p. Otherwise returns 0.
+ */
+int parse_action_control(int *argc_p, char ***argv_p,
+			 int *result_p, bool allow_num)
+{
+	return __parse_action_control(argc_p, argv_p, result_p,
+				      allow_num, false);
+}
+
+/* Parse action control including possible options.
+ *
+ * Parameters:
+ * @argc_p - pointer to argc to parse
+ * @argv_p - pointer to argv to parse
+ * @result_p - pointer to output variable
+ * @allow_num - whether action may be in numeric format already
+ * @default_result - set as a result in case of parsing error
+ *
+ * In case there is an error during parsing, the default result is used.
+ */
+void parse_action_control_dflt(int *argc_p, char ***argv_p,
+			       int *result_p, bool allow_num,
+			       int default_result)
+{
+	if (__parse_action_control(argc_p, argv_p, result_p, allow_num, true))
+		*result_p = default_result;
+}
+
+static int parse_action_control_slash_spaces(int *argc_p, char ***argv_p,
+					     int *result1_p, int *result2_p,
+					     bool allow_num)
+{
+	int argc = *argc_p;
+	char **argv = *argv_p;
+	int result1 = -1, result2;
+	int *result_p = &result1;
+	int ok = 0;
+	int ret;
+
+	while (argc > 0) {
+		switch (ok) {
+		case 1:
+			if (strcmp(*argv, "/") != 0)
+				goto out;
+			result_p = &result2;
+			NEXT_ARG();
+			/* fall-through */
+		case 0: /* fall-through */
+		case 2:
+			ret = parse_action_control(&argc, &argv,
+						   result_p, allow_num);
+			if (ret)
+				return ret;
+			ok++;
+			break;
+		default:
+			goto out;
+		}
+	}
+out:
+	*result1_p = result1;
+	if (ok == 2)
+		*result2_p = result2;
+	*argc_p = argc;
+	*argv_p = argv;
+	return 0;
+}
+
+/* Parse action control with slash including possible options.
+ *
+ * Parameters:
+ * @argc_p - pointer to argc to parse
+ * @argv_p - pointer to argv to parse
+ * @result1_p - pointer to the first (before slash) output variable
+ * @result2_p - pointer to the second (after slash) output variable
+ * @allow_num - whether action may be in numeric format already
+ *
+ * In error case, returns -1 and does not touch @result*. Otherwise returns 0.
+ */
+int parse_action_control_slash(int *argc_p, char ***argv_p,
+			       int *result1_p, int *result2_p, bool allow_num)
+{
+	int result1, result2, argc = *argc_p;
+	char **argv = *argv_p;
+	char *p = strchr(*argv, '/');
+
+	if (!p)
+		return parse_action_control_slash_spaces(argc_p, argv_p,
+							 result1_p, result2_p,
+							 allow_num);
+	*p = 0;
+	if (action_a2n(*argv, &result1, allow_num)) {
+		*p = '/';
+		return -1;
+	}
+
+	*p = '/';
+	if (action_a2n(p + 1, &result2, allow_num))
+		return -1;
+
+	*result1_p = result1;
+	*result2_p = result2;
+	NEXT_ARG_FWD();
+	*argc_p = argc;
+	*argv_p = argv;
+	return 0;
+}
+
+void print_action_control(FILE *f, const char *prefix,
+			  int action, const char *suffix)
+{
+	print_string(PRINT_FP, NULL, "%s", prefix);
+	open_json_object("control_action");
+	print_string(PRINT_ANY, "type", "%s", action_n2a(action));
+	if (TC_ACT_EXT_CMP(action, TC_ACT_GOTO_CHAIN))
+		print_uint(PRINT_ANY, "chain", " chain %u",
+			   action & TC_ACT_EXT_VAL_MASK);
+	if (TC_ACT_EXT_CMP(action, TC_ACT_JUMP))
+		print_uint(PRINT_ANY, "jump", " %u",
+			   action & TC_ACT_EXT_VAL_MASK);
+	close_json_object();
+	print_string(PRINT_FP, NULL, "%s", suffix);
+}
+
+int get_linklayer(unsigned int *val, const char *arg)
+{
+	int res;
+
+	if (matches(arg, "ethernet") == 0)
+		res = LINKLAYER_ETHERNET;
+	else if (matches(arg, "atm") == 0)
+		res = LINKLAYER_ATM;
+	else if (matches(arg, "adsl") == 0)
+		res = LINKLAYER_ATM;
+	else
+		return -1; /* Indicate error */
+
+	*val = res;
+	return 0;
+}
+
+static void print_linklayer(char *buf, int len, unsigned int linklayer)
+{
+	switch (linklayer) {
+	case LINKLAYER_UNSPEC:
+		snprintf(buf, len, "%s", "unspec");
+		return;
+	case LINKLAYER_ETHERNET:
+		snprintf(buf, len, "%s", "ethernet");
+		return;
+	case LINKLAYER_ATM:
+		snprintf(buf, len, "%s", "atm");
+		return;
+	default:
+		snprintf(buf, len, "%s", "unknown");
+		return;
+	}
+}
+
+char *sprint_linklayer(unsigned int linklayer, char *buf)
+{
+	print_linklayer(buf, SPRINT_BSIZE-1, linklayer);
+	return buf;
+}
+
+void print_tm(FILE *f, const struct tcf_t *tm)
+{
+	int hz = get_user_hz();
+
+	if (tm->install != 0) {
+		print_uint(PRINT_JSON, "installed", NULL, tm->install);
+		print_uint(PRINT_FP, NULL, " installed %u sec",
+			   (unsigned int)(tm->install/hz));
+	}
+	if (tm->lastuse != 0) {
+		print_uint(PRINT_JSON, "last_used", NULL, tm->lastuse);
+		print_uint(PRINT_FP, NULL, " used %u sec",
+			   (unsigned int)(tm->lastuse/hz));
+	}
+	if (tm->expires != 0) {
+		print_uint(PRINT_JSON, "expires", NULL, tm->expires);
+		print_uint(PRINT_FP, NULL, " expires %u sec",
+			   (unsigned int)(tm->expires/hz));
+	}
+}
+
+static void print_tcstats_basic_hw(struct rtattr **tbs, char *prefix)
+{
+	struct gnet_stats_basic bs_hw;
+
+	if (!tbs[TCA_STATS_BASIC_HW])
+		return;
+
+	memcpy(&bs_hw, RTA_DATA(tbs[TCA_STATS_BASIC_HW]),
+	       MIN(RTA_PAYLOAD(tbs[TCA_STATS_BASIC_HW]), sizeof(bs_hw)));
+
+	if (bs_hw.bytes == 0 && bs_hw.packets == 0)
+		return;
+
+	if (tbs[TCA_STATS_BASIC]) {
+		struct gnet_stats_basic bs;
+
+		memcpy(&bs, RTA_DATA(tbs[TCA_STATS_BASIC]),
+		       MIN(RTA_PAYLOAD(tbs[TCA_STATS_BASIC]),
+			   sizeof(bs)));
+
+		if (bs.bytes >= bs_hw.bytes && bs.packets >= bs_hw.packets) {
+			print_string(PRINT_FP, NULL, "%s", _SL_);
+			print_string(PRINT_FP, NULL, "%s", prefix);
+			print_lluint(PRINT_ANY, "sw_bytes",
+				     "Sent software %llu bytes",
+				     bs.bytes - bs_hw.bytes);
+			print_uint(PRINT_ANY, "sw_packets", " %u pkt",
+				   bs.packets - bs_hw.packets);
+		}
+	}
+
+	print_string(PRINT_FP, NULL, "%s", _SL_);
+	print_string(PRINT_FP, NULL, "%s", prefix);
+	print_lluint(PRINT_ANY, "hw_bytes", "Sent hardware %llu bytes",
+		     bs_hw.bytes);
+	print_uint(PRINT_ANY, "hw_packets", " %u pkt", bs_hw.packets);
+}
+
+void print_tcstats2_attr(FILE *fp, struct rtattr *rta, char *prefix, struct rtattr **xstats)
+{
+	SPRINT_BUF(b1);
+	struct rtattr *tbs[TCA_STATS_MAX + 1];
+
+	parse_rtattr_nested(tbs, TCA_STATS_MAX, rta);
+
+	if (tbs[TCA_STATS_BASIC]) {
+		struct gnet_stats_basic bs = {0};
+
+		memcpy(&bs, RTA_DATA(tbs[TCA_STATS_BASIC]), MIN(RTA_PAYLOAD(tbs[TCA_STATS_BASIC]), sizeof(bs)));
+		print_string(PRINT_FP, NULL, "%s", prefix);
+		print_lluint(PRINT_ANY, "bytes", "Sent %llu bytes", bs.bytes);
+		print_uint(PRINT_ANY, "packets", " %u pkt", bs.packets);
+	}
+
+	if (tbs[TCA_STATS_QUEUE]) {
+		struct gnet_stats_queue q = {0};
+
+		memcpy(&q, RTA_DATA(tbs[TCA_STATS_QUEUE]), MIN(RTA_PAYLOAD(tbs[TCA_STATS_QUEUE]), sizeof(q)));
+		print_uint(PRINT_ANY, "drops", " (dropped %u", q.drops);
+		print_uint(PRINT_ANY, "overlimits", ", overlimits %u",
+			   q.overlimits);
+		print_uint(PRINT_ANY, "requeues", " requeues %u) ", q.requeues);
+	}
+
+	if (tbs[TCA_STATS_BASIC_HW])
+		print_tcstats_basic_hw(tbs, prefix);
+
+	if (tbs[TCA_STATS_RATE_EST64]) {
+		struct gnet_stats_rate_est64 re = {0};
+
+		memcpy(&re, RTA_DATA(tbs[TCA_STATS_RATE_EST64]),
+		       MIN(RTA_PAYLOAD(tbs[TCA_STATS_RATE_EST64]),
+			   sizeof(re)));
+		print_string(PRINT_FP, NULL, "\n%s", prefix);
+		print_lluint(PRINT_JSON, "rate", NULL, re.bps);
+		print_string(PRINT_FP, NULL, "rate %s",
+			     sprint_rate(re.bps, b1));
+		print_lluint(PRINT_ANY, "pps", " %llupps", re.pps);
+	} else if (tbs[TCA_STATS_RATE_EST]) {
+		struct gnet_stats_rate_est re = {0};
+
+		memcpy(&re, RTA_DATA(tbs[TCA_STATS_RATE_EST]),
+		       MIN(RTA_PAYLOAD(tbs[TCA_STATS_RATE_EST]), sizeof(re)));
+		print_string(PRINT_FP, NULL, "\n%s", prefix);
+		print_uint(PRINT_JSON, "rate", NULL, re.bps);
+		print_string(PRINT_FP, NULL, "rate %s",
+			     sprint_rate(re.bps, b1));
+		print_uint(PRINT_ANY, "pps", " %upps", re.pps);
+	}
+
+	if (tbs[TCA_STATS_QUEUE]) {
+		struct gnet_stats_queue q = {0};
+
+		memcpy(&q, RTA_DATA(tbs[TCA_STATS_QUEUE]), MIN(RTA_PAYLOAD(tbs[TCA_STATS_QUEUE]), sizeof(q)));
+		if (!tbs[TCA_STATS_RATE_EST])
+			print_string(PRINT_FP, NULL, "\n", "");
+		print_uint(PRINT_JSON, "backlog", NULL, q.backlog);
+		print_string(PRINT_FP, NULL, "%s", prefix);
+		print_string(PRINT_FP, NULL, "backlog %s",
+			     sprint_size(q.backlog, b1));
+		print_uint(PRINT_ANY, "qlen", " %up", q.qlen);
+		print_uint(PRINT_FP, NULL, " requeues %u", q.requeues);
+	}
+
+	if (xstats)
+		*xstats = tbs[TCA_STATS_APP] ? : NULL;
+}
+
+void print_tcstats_attr(FILE *fp, struct rtattr *tb[], char *prefix, struct rtattr **xstats)
+{
+	SPRINT_BUF(b1);
+
+	if (tb[TCA_STATS2]) {
+		print_tcstats2_attr(fp, tb[TCA_STATS2], prefix, xstats);
+		if (xstats && NULL == *xstats)
+			goto compat_xstats;
+		return;
+	}
+	/* backward compatibility */
+	if (tb[TCA_STATS]) {
+		struct tc_stats st = {};
+
+		/* handle case where kernel returns more/less than we know about */
+		memcpy(&st, RTA_DATA(tb[TCA_STATS]), MIN(RTA_PAYLOAD(tb[TCA_STATS]), sizeof(st)));
+
+		fprintf(fp, "%sSent %llu bytes %u pkts (dropped %u, overlimits %u) ",
+			prefix, (unsigned long long)st.bytes, st.packets, st.drops,
+			st.overlimits);
+
+		if (st.bps || st.pps || st.qlen || st.backlog) {
+			fprintf(fp, "\n%s", prefix);
+			if (st.bps || st.pps) {
+				fprintf(fp, "rate ");
+				if (st.bps)
+					fprintf(fp, "%s ", sprint_rate(st.bps, b1));
+				if (st.pps)
+					fprintf(fp, "%upps ", st.pps);
+			}
+			if (st.qlen || st.backlog) {
+				fprintf(fp, "backlog ");
+				if (st.backlog)
+					fprintf(fp, "%s ", sprint_size(st.backlog, b1));
+				if (st.qlen)
+					fprintf(fp, "%up ", st.qlen);
+			}
+		}
+	}
+
+compat_xstats:
+	if (tb[TCA_XSTATS] && xstats)
+		*xstats = tb[TCA_XSTATS];
+}
diff -ruN iproute2-4.20.0/tc/tc_util.h iproute2-4.20.0_b/tc/tc_util.h
--- iproute2-4.20.0/tc/tc_util.h	2019-01-07 21:24:02.000000000 +0300
+++ iproute2-4.20.0_b/tc/tc_util.h	2019-03-14 15:27:08.844797498 +0300
@@ -69,6 +69,7 @@
 };
 
 const char *get_tc_lib(void);
+const char *get_tc_datadir(void);
 
 struct qdisc_util *get_qdisc_kind(const char *str);
 struct filter_util *get_filter_kind(const char *str);
diff -ruN iproute2-4.20.0/tc/tc_util.h.orig iproute2-4.20.0_b/tc/tc_util.h.orig
--- iproute2-4.20.0/tc/tc_util.h.orig	1970-01-01 03:00:00.000000000 +0300
+++ iproute2-4.20.0_b/tc/tc_util.h.orig	2019-01-07 21:24:02.000000000 +0300
@@ -0,0 +1,129 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+#ifndef _TC_UTIL_H_
+#define _TC_UTIL_H_ 1
+
+#define MAX_MSG 16384
+#include <limits.h>
+#include <linux/if.h>
+
+#include <linux/pkt_sched.h>
+#include <linux/pkt_cls.h>
+#include <linux/gen_stats.h>
+
+#include "tc_core.h"
+#include "json_print.h"
+
+/* This is the deprecated multiqueue interface */
+#ifndef TCA_PRIO_MAX
+enum
+{
+	TCA_PRIO_UNSPEC,
+	TCA_PRIO_MQ,
+	__TCA_PRIO_MAX
+};
+
+#define TCA_PRIO_MAX    (__TCA_PRIO_MAX - 1)
+#endif
+
+#define FILTER_NAMESZ	16
+
+struct qdisc_util {
+	struct  qdisc_util *next;
+	const char *id;
+	int (*parse_qopt)(struct qdisc_util *qu, int argc,
+			  char **argv, struct nlmsghdr *n, const char *dev);
+	int (*print_qopt)(struct qdisc_util *qu,
+			  FILE *f, struct rtattr *opt);
+	int (*print_xstats)(struct qdisc_util *qu,
+			    FILE *f, struct rtattr *xstats);
+
+	int (*parse_copt)(struct qdisc_util *qu, int argc,
+			  char **argv, struct nlmsghdr *n, const char *dev);
+	int (*print_copt)(struct qdisc_util *qu, FILE *f, struct rtattr *opt);
+};
+
+extern __u16 f_proto;
+struct filter_util {
+	struct filter_util *next;
+	char id[FILTER_NAMESZ];
+	int (*parse_fopt)(struct filter_util *qu, char *fhandle,
+			  int argc, char **argv, struct nlmsghdr *n);
+	int (*print_fopt)(struct filter_util *qu,
+			  FILE *f, struct rtattr *opt, __u32 fhandle);
+};
+
+struct action_util {
+	struct action_util *next;
+	char id[FILTER_NAMESZ];
+	int (*parse_aopt)(struct action_util *a, int *argc,
+			  char ***argv, int code, struct nlmsghdr *n);
+	int (*print_aopt)(struct action_util *au, FILE *f, struct rtattr *opt);
+	int (*print_xstats)(struct action_util *au,
+			    FILE *f, struct rtattr *xstats);
+};
+
+struct exec_util {
+	struct exec_util *next;
+	char id[FILTER_NAMESZ];
+	int (*parse_eopt)(struct exec_util *eu, int argc, char **argv);
+};
+
+const char *get_tc_lib(void);
+
+struct qdisc_util *get_qdisc_kind(const char *str);
+struct filter_util *get_filter_kind(const char *str);
+
+int get_qdisc_handle(__u32 *h, const char *str);
+int get_rate(unsigned int *rate, const char *str);
+int get_percent_rate(unsigned int *rate, const char *str, const char *dev);
+int get_rate64(__u64 *rate, const char *str);
+int get_percent_rate64(__u64 *rate, const char *str, const char *dev);
+int get_size(unsigned int *size, const char *str);
+int get_size_and_cell(unsigned int *size, int *cell_log, char *str);
+int get_linklayer(unsigned int *val, const char *arg);
+
+void print_rate(char *buf, int len, __u64 rate);
+void print_devname(enum output_type type, int ifindex);
+
+char *sprint_rate(__u64 rate, char *buf);
+char *sprint_size(__u32 size, char *buf);
+char *sprint_tc_classid(__u32 h, char *buf);
+char *sprint_ticks(__u32 ticks, char *buf);
+char *sprint_linklayer(unsigned int linklayer, char *buf);
+
+void print_tcstats_attr(FILE *fp, struct rtattr *tb[],
+			char *prefix, struct rtattr **xstats);
+void print_tcstats2_attr(FILE *fp, struct rtattr *rta,
+			 char *prefix, struct rtattr **xstats);
+
+int get_tc_classid(__u32 *h, const char *str);
+int print_tc_classid(char *buf, int len, __u32 h);
+char *sprint_tc_classid(__u32 h, char *buf);
+
+int tc_print_police(FILE *f, struct rtattr *tb);
+int parse_police(int *argc_p, char ***argv_p, int tca_id, struct nlmsghdr *n);
+
+int parse_action_control(int *argc_p, char ***argv_p,
+			 int *result_p, bool allow_num);
+void parse_action_control_dflt(int *argc_p, char ***argv_p,
+			       int *result_p, bool allow_num,
+			       int default_result);
+int parse_action_control_slash(int *argc_p, char ***argv_p,
+			       int *result1_p, int *result2_p, bool allow_num);
+void print_action_control(FILE *f, const char *prefix,
+			  int action, const char *suffix);
+int police_print_xstats(struct action_util *a, FILE *f, struct rtattr *tb);
+int tc_print_action(FILE *f, const struct rtattr *tb, unsigned short tot_acts);
+int tc_print_ipt(FILE *f, const struct rtattr *tb);
+int parse_action(int *argc_p, char ***argv_p, int tca_id, struct nlmsghdr *n);
+void print_tm(FILE *f, const struct tcf_t *tm);
+int prio_print_opt(struct qdisc_util *qu, FILE *f, struct rtattr *opt);
+
+int cls_names_init(char *path);
+void cls_names_uninit(void);
+
+int action_a2n(char *arg, int *result, bool allow_num);
+
+bool tc_qdisc_block_exists(__u32 block_index);
+
+#endif
