diff -ruN firefox-78.2.0-orig/intl/Encoding.h firefox-78.2.0/intl/Encoding.h
--- firefox-78.2.0-orig/intl/Encoding.h	Tue Aug 18 03:33:36 2020
+++ firefox-78.2.0/intl/Encoding.h	Tue Sep 15 01:58:26 2020
@@ -750,7 +750,8 @@
    * UTF-8 or the length of the input if the input is entirely valid.
    */
   static inline size_t UTF8ValidUpTo(Span<const uint8_t> aBuffer) {
-    return encoding_utf8_valid_up_to(aBuffer.Elements(), aBuffer.Length());
+    //return encoding_utf8_valid_up_to(aBuffer.Elements(), aBuffer.Length());
+    return NULL;
   }
 
   /**
@@ -760,7 +761,8 @@
    * ASCII or the length of the input if the input is entirely valid.
    */
   static inline size_t ASCIIValidUpTo(Span<const uint8_t> aBuffer) {
-    return encoding_ascii_valid_up_to(aBuffer.Elements(), aBuffer.Length());
+    //return encoding_ascii_valid_up_to(aBuffer.Elements(), aBuffer.Length());
+    return NULL;
   }
 
   /**
diff -ruN firefox-78.2.0-orig/js/moz.configure firefox-78.2.0/js/moz.configure
--- firefox-78.2.0-orig/js/moz.configure	Tue Aug 18 03:33:37 2020
+++ firefox-78.2.0/js/moz.configure	Tue Sep 15 01:46:07 2020
@@ -35,10 +35,6 @@
 
 include('../build/moz.configure/nspr.configure',
         when='--enable-compile-environment')
-include('../build/moz.configure/rust.configure',
-        when='--enable-compile-environment')
-include('../build/moz.configure/bindgen.configure',
-        when='--enable-compile-environment')
 
 @depends('JS_STANDALONE')
 def js_standalone(value):
@@ -469,10 +465,11 @@
 
 @depends('--enable-rust-simd', target)
 def rust_simd(value, target):
+    return False
     # As of 2019-09-17, the simd-accel feature of encoding_rs has not
     # been properly set up outside aarch64, armv7, x86 and x86_64.
-    if target.cpu in ('aarch64', 'arm', 'x86', 'x86_64') and value:
-        return True
+    #if target.cpu in ('aarch64', 'arm', 'x86', 'x86_64') and value:
+    #    return True
 
 set_config('MOZ_RUST_SIMD', rust_simd)
 set_define('MOZ_RUST_SIMD', rust_simd)
diff -ruN firefox-78.2.0-orig/js/src/util/StringBuffer.cpp firefox-78.2.0/js/src/util/StringBuffer.cpp
--- firefox-78.2.0-orig/js/src/util/StringBuffer.cpp	Tue Aug 18 03:33:46 2020
+++ firefox-78.2.0/js/src/util/StringBuffer.cpp	Tue Sep 15 02:13:19 2020
@@ -67,7 +67,7 @@
 
   twoByte.infallibleGrowByUninitialized(latin1Chars().length());
 
-  mozilla::ConvertLatin1toUtf16(mozilla::AsChars(latin1Chars()), twoByte);
+  //mozilla::ConvertLatin1toUtf16(mozilla::AsChars(latin1Chars()), twoByte);
 
   cb.destroy();
   cb.construct<TwoByteCharBuffer>(std::move(twoByte));
diff -ruN firefox-78.2.0-orig/js/src/util/Text.h firefox-78.2.0/js/src/util/Text.h
--- firefox-78.2.0-orig/js/src/util/Text.h	Tue Aug 18 03:33:50 2020
+++ firefox-78.2.0/js/src/util/Text.h	Tue Sep 15 02:08:49 2020
@@ -243,15 +243,15 @@
  * enough for 'srclen' char16_t code units. The buffer is NOT null-terminated.
  */
 inline void CopyAndInflateChars(char16_t* dst, const char* src, size_t srclen) {
-  mozilla::ConvertLatin1toUtf16(mozilla::MakeSpan(src, srclen),
-                                mozilla::MakeSpan(dst, srclen));
+  //mozilla::ConvertLatin1toUtf16(mozilla::MakeSpan(src, srclen),
+  //                              mozilla::MakeSpan(dst, srclen));
 }
 
 inline void CopyAndInflateChars(char16_t* dst, const JS::Latin1Char* src,
                                 size_t srclen) {
-  mozilla::ConvertLatin1toUtf16(
-      mozilla::AsChars(mozilla::MakeSpan(src, srclen)),
-      mozilla::MakeSpan(dst, srclen));
+  //mozilla::ConvertLatin1toUtf16(
+  //    mozilla::AsChars(mozilla::MakeSpan(src, srclen)),
+  //    mozilla::MakeSpan(dst, srclen));
 }
 
 /*
diff -ruN firefox-78.2.0-orig/js/src/vm/CharacterEncoding.cpp firefox-78.2.0/js/src/vm/CharacterEncoding.cpp
--- firefox-78.2.0-orig/js/src/vm/CharacterEncoding.cpp	Tue Aug 18 03:33:50 2020
+++ firefox-78.2.0/js/src/vm/CharacterEncoding.cpp	Tue Sep 15 02:17:29 2020
@@ -21,13 +21,13 @@
 #include "vm/JSContext.h"
 
 using mozilla::AsChars;
-using mozilla::AsciiValidUpTo;
+//using mozilla::AsciiValidUpTo;
 using mozilla::AsWritableChars;
-using mozilla::ConvertLatin1toUtf8Partial;
-using mozilla::ConvertUtf16toUtf8Partial;
+//using mozilla::ConvertLatin1toUtf8Partial;
+//using mozilla::ConvertUtf16toUtf8Partial;
 using mozilla::IsAscii;
-using mozilla::IsUtf8Latin1;
-using mozilla::LossyConvertUtf16toLatin1;
+//using mozilla::IsUtf8Latin1;
+//using mozilla::LossyConvertUtf16toLatin1;
 using mozilla::MakeSpan;
 using mozilla::Span;
 using mozilla::Tie;
@@ -46,7 +46,7 @@
   if (!latin1) {
     return Latin1CharsZ();
   }
-  LossyConvertUtf16toLatin1(tbchars, AsWritableChars(MakeSpan(latin1, len)));
+  //LossyConvertUtf16toLatin1(tbchars, AsWritableChars(MakeSpan(latin1, len)));
   latin1[len] = '\0';
   return Latin1CharsZ(latin1, len);
 }
@@ -102,14 +102,14 @@
     auto source = AsChars(MakeSpan(src->latin1Chars(nogc), src->length()));
     size_t read;
     size_t written;
-    Tie(read, written) = ConvertLatin1toUtf8Partial(source, dst);
+    //Tie(read, written) = ConvertLatin1toUtf8Partial(source, dst);
     Unused << read;
     return written;
   }
   auto source = MakeSpan(src->twoByteChars(nogc), src->length());
   size_t read;
   size_t written;
-  Tie(read, written) = ConvertUtf16toUtf8Partial(source, dst);
+  //Tie(read, written) = ConvertUtf16toUtf8Partial(source, dst);
   Unused << read;
   return written;
 }
@@ -120,13 +120,13 @@
 template <>
 void ConvertToUTF8<const char16_t>(mozilla::Span<const char16_t> src,
                                    mozilla::Span<char> dst) {
-  Unused << ConvertUtf16toUtf8Partial(src, dst);
+  //Unused << ConvertUtf16toUtf8Partial(src, dst);
 }
 
 template <>
 void ConvertToUTF8<const Latin1Char>(mozilla::Span<const Latin1Char> src,
                                      mozilla::Span<char> dst) {
-  Unused << ConvertLatin1toUtf8Partial(AsChars(src), dst);
+  //Unused << ConvertLatin1toUtf8Partial(AsChars(src), dst);
 }
 
 template <typename CharT>
@@ -476,6 +476,7 @@
 }
 
 JS::SmallestEncoding JS::FindSmallestEncoding(UTF8Chars utf8) {
+#if 0
   Span<unsigned char> unsignedSpan = utf8;
   auto charSpan = AsChars(unsignedSpan);
   size_t upTo = AsciiValidUpTo(charSpan);
@@ -486,6 +487,7 @@
     return SmallestEncoding::Latin1;
   }
   return SmallestEncoding::UTF16;
+#endif
 }
 
 Latin1CharsZ JS::UTF8CharsToNewLatin1CharsZ(JSContext* cx, const UTF8Chars utf8,
diff -ruN firefox-78.2.0-orig/js/src/vm/Initialization.cpp firefox-78.2.0/js/src/vm/Initialization.cpp
--- firefox-78.2.0-orig/js/src/vm/Initialization.cpp	Tue Aug 18 03:33:50 2020
+++ firefox-78.2.0/js/src/vm/Initialization.cpp	Tue Sep 15 01:59:12 2020
@@ -108,7 +108,9 @@
     if (!code) return #code " failed"; \
   } while (0)
 
+#if 0
 extern "C" void install_rust_panic_hook();
+#endif
 
 JS_PUBLIC_API const char* JS::detail::InitWithFailureDiagnostic(
     bool isDebugBuild) {
@@ -127,7 +129,7 @@
 
   libraryInitState = InitState::Initializing;
 
-#ifndef NO_RUST_PANIC_HOOK
+#if 0
   install_rust_panic_hook();
 #endif
 
diff -ruN firefox-78.2.0-orig/js/src/vm/JSContext.cpp firefox-78.2.0/js/src/vm/JSContext.cpp
--- firefox-78.2.0-orig/js/src/vm/JSContext.cpp	Tue Aug 18 03:34:01 2020
+++ firefox-78.2.0/js/src/vm/JSContext.cpp	Tue Sep 15 02:23:42 2020
@@ -369,8 +369,8 @@
       if (utf8Len.isValid()) {
         line = UniqueChars(js_pod_malloc<char>(utf8Len.value()));
         if (line) {
-          n = mozilla::ConvertUtf16toUtf8({linebuf, linebufLen},
-                                          {line.get(), utf8Len.value()});
+          //n = mozilla::ConvertUtf16toUtf8({linebuf, linebufLen},
+          //                                {line.get(), utf8Len.value()});
         }
       }
     }
diff -ruN firefox-78.2.0-orig/js/src/vm/StringType.cpp firefox-78.2.0/js/src/vm/StringType.cpp
--- firefox-78.2.0-orig/js/src/vm/StringType.cpp	Tue Aug 18 03:33:50 2020
+++ firefox-78.2.0/js/src/vm/StringType.cpp	Tue Sep 15 02:22:39 2020
@@ -48,10 +48,10 @@
 using mozilla::ArrayEqual;
 using mozilla::AssertedCast;
 using mozilla::AsWritableChars;
-using mozilla::ConvertLatin1toUtf16;
+//using mozilla::ConvertLatin1toUtf16;
 using mozilla::IsAsciiDigit;
-using mozilla::IsUtf16Latin1;
-using mozilla::LossyConvertUtf16toLatin1;
+//using mozilla::IsUtf16Latin1;
+//using mozilla::LossyConvertUtf16toLatin1;
 using mozilla::MakeSpan;
 using mozilla::PodCopy;
 using mozilla::RangedPtr;
@@ -165,8 +165,8 @@
           mozilla::MakeSpan(linear.latin1Chars(nogc), linear.length()));
       size_t read;
       size_t written;
-      mozilla::Tie(read, written) =
-          mozilla::ConvertLatin1toUtf8Partial(src, buffer);
+      mozilla::Tie(read, written); /* =
+          mozilla::ConvertLatin1toUtf8Partial(src, buffer); */
       buffer = buffer.From(written);
       totalRead += read;
       totalWritten += written;
@@ -220,8 +220,8 @@
       }
       size_t read;
       size_t written;
-      mozilla::Tie(read, written) =
-          mozilla::ConvertUtf16toUtf8Partial(src, buffer);
+      mozilla::Tie(read, written); /* =
+          mozilla::ConvertUtf16toUtf8Partial(src, buffer); */
       buffer = buffer.From(written);
       totalRead += read;
       totalWritten += written;
@@ -538,6 +538,7 @@
 
 template <>
 void CopyChars(Latin1Char* dest, const JSLinearString& str) {
+#if 0
   AutoCheckCannotGC nogc;
   if (str.hasLatin1Chars()) {
     PodCopy(dest, str.latin1Chars(nogc), str.length());
@@ -556,6 +557,7 @@
     MOZ_ASSERT(IsUtf16Latin1(src));
     LossyConvertUtf16toLatin1(src, AsWritableChars(MakeSpan(dest, len)));
   }
+#endif
 }
 
 } /* namespace js */
@@ -926,7 +928,7 @@
  */
 static inline void FillChars(char16_t* dest, const unsigned char* src,
                              size_t length) {
-  ConvertLatin1toUtf16(AsChars(MakeSpan(src, length)), MakeSpan(dest, length));
+  //ConvertLatin1toUtf16(AsChars(MakeSpan(src, length)), MakeSpan(dest, length));
 }
 
 static inline void FillChars(char16_t* dest, const char16_t* src,
@@ -957,8 +959,8 @@
  */
 static inline void FillFromCompatible(unsigned char* dest, const char16_t* src,
                                       size_t length) {
-  LossyConvertUtf16toLatin1(MakeSpan(src, length),
-                            AsWritableChars(MakeSpan(dest, length)));
+  //LossyConvertUtf16toLatin1(MakeSpan(src, length),
+  //                          AsWritableChars(MakeSpan(dest, length)));
 }
 
 static inline void FillFromCompatible(unsigned char* dest,
@@ -1497,7 +1499,7 @@
 }
 
 static inline bool CanStoreCharsAsLatin1(const char16_t* s, size_t length) {
-  return IsUtf16Latin1(MakeSpan(s, length));
+  //return IsUtf16Latin1(MakeSpan(s, length));
 }
 
 static bool CanStoreCharsAsLatin1(LittleEndianChars chars, size_t length) {
diff -ruN firefox-78.2.0-orig/mfbt/JsRust.h firefox-78.2.0/mfbt/JsRust.h
--- firefox-78.2.0-orig/mfbt/JsRust.h	Tue Aug 18 03:34:06 2020
+++ firefox-78.2.0/mfbt/JsRust.h	Tue Sep 15 01:57:21 2020
@@ -13,7 +13,7 @@
 
 #if (defined(MOZ_HAS_MOZGLUE) || defined(MOZILLA_INTERNAL_API)) && \
     !defined(MOZ_PRETEND_NO_JSRUST)
-#  define MOZ_HAS_JSRUST() 1
+#  define MOZ_HAS_JSRUST() 0
 #else
 #  define MOZ_HAS_JSRUST() 0
 #endif
diff -ruN firefox-78.2.0-orig/mfbt/Latin1.h firefox-78.2.0/mfbt/Latin1.h
--- firefox-78.2.0-orig/mfbt/Latin1.h	Tue Aug 18 03:34:18 2020
+++ firefox-78.2.0/mfbt/Latin1.h	Tue Sep 15 01:52:08 2020
@@ -18,7 +18,7 @@
 #include "mozilla/Span.h"
 #include "mozilla/Tuple.h"
 
-#if MOZ_HAS_JSRUST()
+#if 0
 #  include "encoding_rs_mem.h"
 #endif
 
@@ -63,7 +63,7 @@
   return uc >= 0x80 && uc <= 0xFF;
 }
 
-#if MOZ_HAS_JSRUST()
+#if 0
 
 /**
  * Returns |true| iff |aString| contains only Latin1 characters, that is,
diff -ruN firefox-78.2.0-orig/mfbt/TextUtils.h firefox-78.2.0/mfbt/TextUtils.h
--- firefox-78.2.0-orig/mfbt/TextUtils.h	Tue Aug 18 03:34:18 2020
+++ firefox-78.2.0/mfbt/TextUtils.h	Tue Sep 15 01:52:47 2020
@@ -12,7 +12,7 @@
 #include "mozilla/Assertions.h"
 #include "mozilla/Latin1.h"
 
-#ifdef MOZ_HAS_JSRUST
+#if 0
 // Can't include mozilla/Encoding.h here.
 extern "C" {
 // Declared as uint8_t instead of char to match declaration in another header.
@@ -56,7 +56,7 @@
  * @param aString a 8-bit wide string to scan
  */
 inline bool IsAscii(mozilla::Span<const char> aString) {
-#if MOZ_HAS_JSRUST()
+#if 0
   size_t length = aString.Length();
   const char* ptr = aString.Elements();
   // For short strings, avoid the function call, since, the SIMD
@@ -70,14 +70,13 @@
     return accu < 0x80;
   }
   return encoding_mem_is_ascii(ptr, length);
-#else
+#endif
   for (char c : aString) {
     if (!IsAscii(c)) {
       return false;
     }
   }
   return true;
-#endif
 }
 
 /**
@@ -87,7 +86,7 @@
  * @param aString a 16-bit wide string to scan
  */
 inline bool IsAscii(mozilla::Span<const char16_t> aString) {
-#if MOZ_HAS_JSRUST()
+#if 0
   size_t length = aString.Length();
   const char16_t* ptr = aString.Elements();
   // For short strings, calling into Rust is a pessimization, and the SIMD
@@ -103,14 +102,13 @@
     return accu < 0x80;
   }
   return encoding_mem_is_basic_latin(ptr, length);
-#else
+#endif
   for (char16_t c : aString) {
     if (!IsAscii(c)) {
       return false;
     }
   }
   return true;
-#endif
 }
 
 /**
@@ -127,7 +125,7 @@
   return true;
 }
 
-#if MOZ_HAS_JSRUST()
+#if 0
 /**
  * Returns the index of the first non-ASCII byte or
  * the length of the string if there are none.
diff -ruN firefox-78.2.0-orig/mfbt/Utf8.h firefox-78.2.0/mfbt/Utf8.h
--- firefox-78.2.0-orig/mfbt/Utf8.h	Tue Aug 18 03:34:18 2020
+++ firefox-78.2.0/mfbt/Utf8.h	Tue Sep 15 01:53:56 2020
@@ -25,19 +25,18 @@
 #include <stddef.h>  // for size_t
 #include <stdint.h>  // for uint8_t
 
-#if MOZ_HAS_JSRUST()
+#if 0
 // Can't include mozilla/Encoding.h here.
 extern "C" {
 // Declared as uint8_t instead of char to match declaration in another header.
 size_t encoding_utf8_valid_up_to(uint8_t const* buffer, size_t buffer_len);
 }
-#else
+#endif
 namespace mozilla {
 namespace detail {
 extern MFBT_API bool IsValidUtf8(const void* aCodeUnits, size_t aCount);
 };  // namespace detail
 };  // namespace mozilla
-#endif  // MOZ_HAS_JSRUST
 
 namespace mozilla {
 
@@ -252,7 +251,7 @@
  * The string *may* contain U+0000 NULL code points.
  */
 inline bool IsUtf8(mozilla::Span<const char> aString) {
-#if MOZ_HAS_JSRUST()
+#if 0
   size_t length = aString.Length();
   const uint8_t* ptr = reinterpret_cast<const uint8_t*>(aString.Elements());
   // For short strings, the function call is a pessimization, and the SIMD
@@ -269,12 +268,11 @@
   }
 end:
   return length == encoding_utf8_valid_up_to(ptr, length);
-#else
-  return detail::IsValidUtf8(aString.Elements(), aString.Length());
 #endif
+  return detail::IsValidUtf8(aString.Elements(), aString.Length());
 }
 
-#if MOZ_HAS_JSRUST()
+#if 0
 
 // See Latin1.h for conversions between Latin1 and UTF-8.
 
File firefox-78.2.0-orig/obj-x86_64-pc-linux-gnu/_virtualenvs/init/local/lib is not a regular file or directory and was skipped
diff -ruN firefox-78.2.0-orig/python/mozbuild/mozbuild/frontend/data.py firefox-78.2.0/python/mozbuild/mozbuild/frontend/data.py
--- firefox-78.2.0-orig/python/mozbuild/mozbuild/frontend/data.py	Tue Aug 18 03:34:22 2020
+++ firefox-78.2.0/python/mozbuild/mozbuild/frontend/data.py	Tue Sep 15 01:46:07 2020
@@ -559,13 +559,14 @@
 
 
 def cargo_output_directory(context, target_var):
+    return target_var
     # cargo creates several directories and places its build artifacts
     # in those directories.  The directory structure depends not only
     # on the target, but also what sort of build we are doing.
-    rust_build_kind = 'release'
-    if context.config.substs.get('MOZ_DEBUG_RUST'):
-        rust_build_kind = 'debug'
-    return mozpath.join(context.config.substs[target_var], rust_build_kind)
+    #rust_build_kind = 'release'
+    #if context.config.substs.get('MOZ_DEBUG_RUST'):
+    #    rust_build_kind = 'debug'
+    #return mozpath.join(context.config.substs[target_var], rust_build_kind)
 
 
 # Rust programs aren't really Linkable, since Cargo handles all the details
